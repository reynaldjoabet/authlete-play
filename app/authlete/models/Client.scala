/**
  * Authlete API Authlete API Document.
  *
  * The version of the OpenAPI document: 2.3.12 Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package authlete
package models

import scala.collection.immutable.Seq
import com.github.plokhotnyuk.jsoniter_scala.core.JsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.ConfiguredJsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMaker
import io.circe.{Decoder, Encoder, Json}
import io.circe.syntax.*

/**
  * @param number
  *   The sequential number of the client. The value of this property is assigned by Authlete.
  * @param serviceNumber
  *   The sequential number of the service of the client application. The value of this property is
  *   assigned by Authlete.
  * @param developer
  *   The developer of the client application.
  * @param clientName
  *   The name of the client application. This property corresponds to `client_name` in [OpenID
  *   Connect Dynamic Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param clientNames
  *   Client names with language tags. If the client application has different names for different
  *   languages, this property can be used to register the names.
  * @param description
  *   The description about the client application.
  * @param descriptions
  *   Descriptions about the client application with language tags. If the client application has
  *   different descriptions for different languages, this property can be used to register the
  *   descriptions.
  * @param clientId
  *   The client ID. The value of this property is assigned by Authlete.
  * @param clientSecret
  *   The client secret. A random 512-bit value encoded by base64url (86 letters). The value of this
  *   property is assigned by Authlete. Note that Authlete issues a client secret even to a
  *   \"public\" client application, but the client application should not use the client secret
  *   unless it changes its client type to \"confidential\". That is, a public client application
  *   should behave as if it had not been issued a client secret. To be specific, a token request
  *   from a public client of Authlete should not come along with a client secret although [RFC
  *   6749, 3.2.1. Client
  *   Authentication](https://datatracker.ietf.org/doc/html/rfc6749#section-3.2.1) says as follows.
  *   > Confidential clients or other clients issued client credentials MUST authenticate with the
  *   authorization server as described in Section 2.3 when making requests to the token endpoint.
  * @param clientIdAlias
  *   The alias of the client ID. Note that the client ID alias is recognized only when this
  *   client's `clientIdAliasEnabled` property is set to `true` AND the service's
  *   `clientIdAliasEnabled` property is also set to `true`.
  * @param clientIdAliasEnabled
  *   The flag to indicate whether the client ID alias is enabled or not. Note that a service also
  *   has `clientIdAliasEnabled` property. If the service's `clientIdAliasEnabled` property is set
  *   to `false`, the client ID alias of this client is not recognized even if this client's
  *   `clientIdAliasEnabled` property is set to `true`.
  * @param clientType
  * @param applicationType
  * @param logoUri
  *   The URL pointing to the logo image of the client application. This property corresponds to
  *   `logo_uri` in [OpenID Connect Dynamic Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param logoUris
  *   Logo image URLs with language tags. If the client application has different logo images for
  *   different languages, this property can be used to register URLs of the images.
  * @param contacts
  *   An array of email addresses of people responsible for the client application. This property
  *   corresponds to contacts in [OpenID Connect Dynamic Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param tlsClientCertificateBoundAccessTokens
  *   The flag to indicate whether this client use TLS client certificate bound access tokens.
  * @param dynamicallyRegistered
  *   The flag to indicate whether this client has been registered dynamically. For more details,
  *   see [RFC 7591](https://datatracker.ietf.org/doc/html/rfc7591).
  * @param softwareId
  *   The unique identifier string assigned by the client developer or software publisher used by
  *   registration endpoints to identify the client software to be dynamically registered. This
  *   property corresponds to the `software_id metadata` defined in [2. Client
  *   Metadata](https://datatracker.ietf.org/doc/html/rfc7591#section-2) of [RFC
  *   7591](https://datatracker.ietf.org/doc/html/rfc7591).
  * @param softwareVersion
  *   The version identifier string for the client software identified by the software ID. This
  *   property corresponds to the software_version metadata defined in [2. Client
  *   Metadata](https://datatracker.ietf.org/doc/html/rfc7591#section-2) of [RFC
  *   7591](https://datatracker.ietf.org/doc/html/rfc7591).
  * @param registrationAccessTokenHash
  *   The hash of the registration access token for this client.
  * @param createdAt
  *   The time at which this client was created. The value is represented as milliseconds since the
  *   UNIX epoch (1970-01-01).
  * @param modifiedAt
  *   The time at which this client was last modified. The value is represented as milliseconds
  *   since the UNIX epoch (1970-01-01).
  * @param grantTypes
  *   A string array of grant types which the client application declares that it will restrict
  *   itself to using. This property corresponds to `grant_types` in [OpenID Connect Dynamic Client
  *   Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param responseTypes
  *   A string array of response types which the client application declares that it will restrict
  *   itself to using. This property corresponds to `response_types` in [OpenID Connect Dynamic
  *   Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param redirectUris
  *   Redirect URIs that the client application uses to receive a response from the authorization
  *   endpoint. Requirements for a redirect URI are as follows. **Requirements by RFC 6749** (From
  *   [RFC 6749, 3.1.2. Redirection
  *   Endpoint](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2)) - Must be an absolute
  *   URI. - Must not have a fragment component. **Requirements by OpenID Connect** (From \"[OpenID
  *   Connect Dynamic Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata),
  *   application_type\") - The scheme of the redirect URI used for Implicit Grant by a client
  *   application whose application is `web` must be `https`. This is checked at runtime by
  *   Authlete. - The hostname of the redirect URI used for Implicit Grant by a client application
  *   whose application type is `web` must not be `localhost`. This is checked at runtime by
  *   Authlete. - The scheme of the redirect URI used by a client application whose application type
  *   is `native` must be either (1) a custom scheme or (2) `http`, which is allowed only when the
  *   hostname part is `localhost`. This is checked at runtime by Authlete. **Requirements by
  *   Authlete** - Must consist of printable ASCII letters only. - Must not exceed 200 letters. Note
  *   that Authlete allows the application type to be `null`. In other words, a client application
  *   does not have to choose `web` or `native` as its application type. If the application type is
  *   `null`, the requirements by OpenID Connect are not checked at runtime. An authorization
  *   request from a client application which has not registered any redirect URI fails unless at
  *   least all the following conditions are satisfied. - The client type of the client application
  *   is `confidential`. - The value of `response_type` request parameter is `code`. - The
  *   authorization request has the `redirect_uri` request parameter. - The value of `scope` request
  *   parameter does not contain `openid`. RFC 6749 allows partial match of redirect URI under some
  *   conditions (see [RFC 6749, 3.1.2.2. Registration
  *   Requirements](https://datatracker.ietf.org/doc/html/rfc6749#section-3.1.2.2) for details), but
  *   OpenID Connect requires exact match.
  * @param authorizationSignAlg
  * @param authorizationEncryptionAlg
  * @param authorizationEncryptionEnc
  * @param tokenAuthMethod
  * @param tokenAuthSignAlg
  * @param selfSignedCertificateKeyId
  *   The key ID of a JWK containing a self-signed certificate of this client.
  * @param tlsClientAuthSubjectDn
  *   The string representation of the expected subject distinguished name of the certificate this
  *   client will use in mutual TLS authentication. See `tls_client_auth_subject_dn` in \"Mutual TLS
  *   Profiles for OAuth Clients, 2.3. Dynamic Client Registration\" for details.
  * @param tlsClientAuthSanDns
  *   The string representation of the expected DNS subject alternative name of the certificate this
  *   client will use in mutual TLS authentication. See `tls_client_auth_san_dns` in \"Mutual TLS
  *   Profiles for OAuth Clients, 2.3. Dynamic Client Registration\" for details.
  * @param tlsClientAuthSanUri
  *   The string representation of the expected URI subject alternative name of the certificate this
  *   client will use in mutual TLS authentication. See `tls_client_auth_san_uri` in \"Mutual TLS
  *   Profiles for OAuth Clients, 2.3. Dynamic Client Registration\" for details.
  * @param tlsClientAuthSanIp
  *   The string representation of the expected IP address subject alternative name of the
  *   certificate this client will use in mutual TLS authentication. See `tls_client_auth_san_ip` in
  *   \"Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client Registration\" for details.
  * @param tlsClientAuthSanEmail
  *   The string representation of the expected email address subject alternative name of the
  *   certificate this client will use in mutual TLS authentication. See `tls_client_auth_san_email`
  *   in \"Mutual TLS Profiles for OAuth Clients, 2.3. Dynamic Client Registration\" for details.
  * @param parRequired
  *   The flag to indicate whether this client is required to use the pushed authorization request
  *   endpoint. This property corresponds to the `require_pushed_authorization_requests` client
  *   metadata defined in \"OAuth 2.0 Pushed Authorization Requests\".
  * @param requestObjectRequired
  *   The flag to indicate whether authorization requests from this client are always required to
  *   utilize a request object by using either `request` or `request_uri` request parameter. If this
  *   flag is set to `true` and the service's `traditionalRequestObjectProcessingApplied` is set to
  *   `false`, authorization requests from this client are processed as if
  *   `require_signed_request_object` client metadata of this client is `true`. The metadata is
  *   defined in \"JAR (JWT Secured Authorization Request)\".
  * @param requestSignAlg
  * @param requestEncryptionAlg
  * @param requestEncryptionEnc
  * @param requestUris
  *   An array of URLs each of which points to a request object. Authlete requires that URLs used as
  *   values for `request_uri` request parameter be pre-registered. This property is used for the
  *   pre-registration. See [OpenID Connect Core 1.0, 6.2. Passing a Request Object by
  *   Reference](https://openid.net/specs/openid-connect-core-1_0.html#RequestUriParameter) for
  *   details.
  * @param defaultMaxAge
  *   The default maximum authentication age in seconds. This value is used when an authorization
  *   request from the client application does not have `max_age` request parameter. This property
  *   corresponds to `default_max_age` in [OpenID Connect Dynamic Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param defaultAcrs
  *   The default ACRs (Authentication Context Class References). This value is used when an
  *   authorization request from the client application has neither `acr_values` request parameter
  *   nor `acr` claim in claims request parameter.
  * @param idTokenSignAlg
  * @param idTokenEncryptionAlg
  * @param idTokenEncryptionEnc
  * @param authTimeRequired
  *   The flag to indicate whether this client requires `auth_time` claim to be embedded in the ID
  *   token. This property corresponds to `require_auth_time` in [OpenID Connect Dynamic Client
  *   Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param subjectType
  * @param sectorIdentifierUri
  *   The value of the sector identifier URI. This represents the `sector_identifier_uri` client
  *   metadata which is defined in [OpenID Connect Dynamic Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata)
  * @param derivedSectorIdentifier
  *   The sector identifier host component as derived from either the `sector_identifier_uri` or the
  *   registered redirect URI. If no `sector_identifier_uri` is registered and multiple redirect
  *   URIs are also registered, the value of this property is `null`.
  * @param jwksUri
  *   The URL pointing to the JWK Set of the client application. The content pointed to by the URL
  *   is JSON which complies with the format described in [JSON Web Key (JWK), 5. JWK Set
  *   Format](https://datatracker.ietf.org/doc/html/rfc7517#section-5). The JWK Set must not include
  *   private keys of the client application. If the client application requests encryption for ID
  *   tokens (from the authorization/token/userinfo endpoints) and/or signs request objects, it must
  *   make available its JWK Set containing public keys for the encryption and/or the signature at
  *   the URL of `jwksUri`. The service (Authlete) fetches the JWK Set from the URL as necessary.
  *   [OpenID Connect Dynamic Client Registration
  *   1.0](https://openid.net/specs/openid-connect-registration-1_0.html) says that `jwks` must not
  *   be used when the client can use `jwks_uri`, but Authlete allows both properties to be
  *   registered at the same time. However, Authlete does not use the content of `jwks` when
  *   `jwksUri` is registered. This property corresponds to `jwks_uri` in [OpenID Connect Dynamic
  *   Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param jwks
  *   The content of the JWK Set of the client application. The format is described in [JSON Web Key
  *   (JWK), 5. JWK Set Format](https://datatracker.ietf.org/doc/html/rfc7517#section-5). The JWK
  *   Set must not include private keys of the client application. [OpenID Connect Dynamic Client
  *   Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) says that
  *   `jwks` must not be used when the client can use `jwks_uri`, but Authlete allows both
  *   properties to be registered at the same time. However, Authlete does not use the content of
  *   `jwks` when `jwksUri` is registered. This property corresponds to `jwks_uri` in [OpenID
  *   Connect Dynamic Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param userInfoSignAlg
  * @param userInfoEncryptionAlg
  * @param userInfoEncryptionEnc
  * @param loginUri
  *   The URL which a third party can use to initiate a login by the client application. This
  *   property corresponds to `initiate_login_uri` in [OpenID Connect Dynamic Client Registration
  *   1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param tosUri
  *   The URL pointing to the \"Terms Of Service\" page. This property corresponds to `tos_uri` in
  *   [OpenID Connect Dynamic Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param tosUris
  *   URLs of \"Terms Of Service\" pages with language tags. If the client application has different
  *   \"Terms Of Service\" pages for different languages, this property can be used to register the
  *   URLs.
  * @param policyUri
  *   The URL pointing to the page which describes the policy as to how end-user's profile data is
  *   used. This property corresponds to `policy_uri` in [OpenID Connect Dynamic Client Registration
  *   1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param policyUris
  *   URLs of policy pages with language tags. If the client application has different policy pages
  *   for different languages, this property can be used to register the URLs.
  * @param clientUri
  *   The URL pointing to the home page of the client application. This property corresponds to
  *   `client_uri` in [OpenID Connect Dynamic Client Registration 1.0, 2. Client
  *   Metadata](https://openid.net/specs/openid-connect-registration-1_0.html#ClientMetadata).
  * @param clientUris
  *   Home page URLs with language tags. If the client application has different home pages for
  *   different languages, this property can be used to register the URLs.
  * @param bcDeliveryMode
  *   The backchannel token delivery mode. This property corresponds to the
  *   `backchannel_token_delivery_mode` metadata. The backchannel token delivery mode is defined in
  *   the specification of \"CIBA (Client Initiated Backchannel Authentication)\".
  * @param bcNotificationEndpoint
  *   The backchannel client notification endpoint. This property corresponds to the
  *   `backchannel_client_notification_endpoint` metadata. The backchannel token delivery mode is
  *   defined in the specification of \"CIBA (Client Initiated Backchannel Authentication)\".
  * @param bcRequestSignAlg
  * @param bcUserCodeRequired
  *   The boolean flag to indicate whether a user code is required when this client makes a
  *   backchannel authentication request. This property corresponds to the
  *   `backchannel_user_code_parameter` metadata.
  * @param attributes
  *   The attributes of this client.
  * @param extension
  * @param authorizationDetailsTypes
  *   The authorization details types that this client may use as values of the `type` field in
  *   `authorization_details`. This property corresponds to the `authorization_details_types`
  *   metadata. See [OAuth 2.0 Rich Authorization Requests
  *   (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/) for details. Note that the
  *   property name was renamed from authorizationDataTypes to authorizationDetailsTypes to align
  *   with the change made by the 5th draft of the RAR specification.
  * @param customMetadata
  *   The custom client metadata in JSON format. Standard specifications define client metadata as
  *   necessary. The following are such examples. * [OpenID Connect Dynamic Client Registration
  *   1.0](https://openid.net/specs/openid-connect-registration-1_0.html) * [RFC 7591 OAuth 2.0
  *   Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html) * [RFC 8705
  *   OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access
  *   Tokens](https://www.rfc-editor.org/rfc/rfc8705.html) * [OpenID Connect Client-Initiated
  *   Backchannel Authentication Flow - Core
  *   1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
  *   * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request
  *   (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/) * [Financial-grade API: JWT
  *   Secured Authorization Response Mode for OAuth 2.0
  *   (JARM)](https://openid.net/specs/openid-financial-api-jarm.html) * [OAuth 2.0 Pushed
  *   Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/) * [OAuth 2.0 Rich
  *   Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/) Standard
  *   client metadata included in Client Registration Request and Client Update Request (cf. [OIDC
  *   DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC
  *   7591](https://www.rfc-editor.org/rfc/rfc7591.html) and [RFC
  *   7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, set to
  *   corresponding properties of the client application. For example, the value of the
  *   `client_name` client metadata in Client Registration/Update Request is set to the clientName
  *   property. On the other hand, unrecognized client metadata are discarded. By listing up custom
  *   client metadata in advance by using the `supportedCustomClientMetadata` property of Service,
  *   Authlete can recognize them and stores their values into the database. The stored custom
  *   client metadata values can be referenced by this property.
  * @param frontChannelRequestObjectEncryptionRequired
  *   The flag indicating whether encryption of request object is required when the request object
  *   is passed through the front channel. This flag does not affect the processing of request
  *   objects at the Pushed Authorization Request Endpoint, which is defined in [OAuth 2.0 Pushed
  *   Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/). Unecrypted request objects
  *   are accepted at the endpoint even if this flag is `true`. This flag does not indicate whether
  *   a request object is always required. There is a different flag, `requestObjectRequired`, for
  *   the purpose. Even if this flag is `false`, encryption of request object is required if the
  *   `frontChannelRequestObjectEncryptionRequired` flag of the service is `true`.
  * @param requestObjectEncryptionAlgMatchRequired
  *   The flag indicating whether the JWE alg of encrypted request object must match the
  *   `request_object_encryption_alg` client metadata. The `request_object_encryption_alg` client
  *   metadata itself is defined in [OpenID Connect Dynamic Client Registration
  *   1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows. >
  *   request_object_encryption_alg > > OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring
  *   that it may use for encrypting Request Objects sent to the OP. This parameter SHOULD be
  *   included when symmetric encryption will be used, since this signals to the OP that a
  *   client_secret value needs to be returned from which the symmetric key will be derived, that
  *   might not otherwise be returned. The RP MAY still use other supported encryption algorithms or
  *   send unencrypted Request Objects, even when this parameter is present. If both signing and
  *   encryption are requested, the Request Object will be signed then encrypted, with the result
  *   being a Nested JWT, as defined in [JWT]. The default, if omitted, is that the RP is not
  *   declaring whether it might encrypt any Request Objects. The point here is \"The RP MAY still
  *   use other supported encryption algorithms or send unencrypted Request Objects, even when this
  *   parameter is present.\" The property that represents the client metadata is
  *   `requestEncryptionAlg`. See the description of `requestEncryptionAlg` for details. Even if
  *   this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
  *   flag of the service is `true`.
  * @param requestObjectEncryptionEncMatchRequired
  *   The flag indicating whether the JWE enc of encrypted request object must match the
  *   `request_object_encryption_enc` client metadata. The `request_object_encryption_enc` client
  *   metadata itself is defined in [OpenID Connect Dynamic Client Registration
  *   1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows. >
  *   request_object_encryption_enc > > OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that
  *   it may use for encrypting Request Objects sent to the OP. If request_object_encryption_alg is
  *   specified, the default for this value is A128CBC-HS256. When request_object_encryption_enc is
  *   included, request_object_encryption_alg MUST also be provided. The property that represents
  *   the client metadata is `requestEncryptionEnc`. See the description of `requestEncryptionEnc`
  *   for details. Even if this flag is `false`, the match is required if the
  *   `requestObjectEncryptionEncMatchRequired` flag of the service is `true`.
  * @param digestAlgorithm
  *   The digest algorithm that this client requests the server to use when it computes digest
  *   values of <a href=
  *   \"https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#name-external-attachments\"
  *   >external attachments</a>, which may be referenced from within ID tokens or userinfo responses
  *   (or any place that can have the `verified_claims` claim). Possible values are listed in the <a
  *   href= \"https://www.iana.org/assignments/named-information/named-information.xhtml#hash-alg\"
  *   >Hash Algorithm Registry</a> of IANA (Internet Assigned Numbers Authority), but the server
  *   does not necessarily support all the values there. When this property is omitted, `sha-256` is
  *   used as the default algorithm. This property corresponds to the `digest_algorithm` client
  *   metadata which was defined by the third implementer's draft of [OpenID Connect for Identity
  *   Assurance 1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html).
  * @param singleAccessTokenPerSubject
  *   If `Enabled` is selected, an attempt to issue a new access token invalidates existing access
  *   tokens that are associated with the same combination of subject and client. Note that,
  *   however, attempts by Client Credentials Flow do not invalidate existing access tokens because
  *   access tokens issued by Client Credentials Flow are not associated with any end-user's
  *   subject. Even if `Disabled` is selected here, single access token per subject is effective if
  *   `singleAccessTokenPerSubject` of the `Service` this client belongs to is Enabled.
  * @param pkceRequired
  *   The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required
  *   for authorization requests by Authorization Code Flow. If `true`, `code_challenge` request
  *   parameter is always required for authorization requests using Authorization Code Flow. See
  *   [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public
  *   Clients) for details about `code_challenge` request parameter.
  * @param pkceS256Required
  *   The flag to indicate whether `S256` is always required as the code challenge method whenever
  *   [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used. If this flag is set to `true`,
  *   `code_challenge_method=S256` must be included in the authorization request whenever it
  *   includes the `code_challenge` request parameter. Neither omission of the
  *   `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is
  *   allowed.
  * @param dpopRequired
  *   If the DPoP is required for this client
  * @param automaticallyRegistered
  *   The flag indicating whether this client was registered by the \"automatic\" client
  *   registration of OIDC Federation.
  * @param explicitlyRegistered
  *   The flag indicating whether this client was registered by the \"explicit\" client registration
  *   of OIDC Federation.
  * @param rsRequestSigned
  *   The flag indicating whether this service signs responses from the resource server.
  * @param rsSignedRequestKeyId
  *   Get the key ID of a JWK containing the public key used by this client to sign requests to the
  *   resource server.
  * @param clientRegistrationTypes
  *   Get the client registration types that the client has declared it may use.
  * @param organizationName
  *   Get the human-readable name representing the organization that manages this client. This
  *   property corresponds to the organization_name client metadata that is defined in OpenID
  *   Connect Federation 1.0.
  * @param signedJwksUri
  *   Get the URI of the endpoint that returns this client's JWK Set document in the JWT format.
  *   This property corresponds to the `signed_jwks_uri` client metadata defined in OpenID Connect
  *   Federation 1.0.
  * @param entityId
  *   the entity ID of this client.
  * @param trustAnchorId
  *   The entity ID of the trust anchor of the trust chain that was used when this client was
  *   registered or updated by the mechanism defined in OpenID Connect Federation 1.0
  * @param trustChain
  *   The trust chain that was used when this client was registered or updated by the mechanism
  *   defined in OpenID Connect Federation 1.0
  * @param trustChainExpiresAt
  *   the expiration time of the trust chain that was used when this client was registered or
  *   updated by the mechanism defined in OpenID Connect Federation 1.0. The value is represented as
  *   milliseconds elapsed since the Unix epoch (1970-01-01).
  * @param trustChainUpdatedAt
  *   the time at which the trust chain was updated by the mechanism defined in OpenID Connect
  *   Federation 1.0
  * @param locked
  *   The flag which indicates whether this client is locked.
  */
case class Client(
    number: Option[Int] = None,
    serviceNumber: Option[Int] = None,
    developer: Option[String] = None,
    clientName: Option[String] = None,
    clientNames: Option[Seq[TaggedValue]] = None,
    description: Option[String] = None,
    descriptions: Option[Seq[TaggedValue]] = None,
    clientId: Option[Long] = None,
    clientSecret: Option[String] = None,
    clientIdAlias: Option[String] = None,
    clientIdAliasEnabled: Option[Boolean] = None,
    clientType: Option[ClientType] = None,
    applicationType: Option[ApplicationType] = None,
    logoUri: Option[String] = None,
    logoUris: Option[Seq[TaggedValue]] = None,
    contacts: Option[Seq[String]] = None,
    tlsClientCertificateBoundAccessTokens: Option[Boolean] = None,
    dynamicallyRegistered: Option[Boolean] = None,
    softwareId: Option[String] = None,
    softwareVersion: Option[String] = None,
    registrationAccessTokenHash: Option[String] = None,
    createdAt: Option[Long] = None,
    modifiedAt: Option[Long] = None,
    grantTypes: Option[Seq[GrantType]] = None,
    responseTypes: Option[Seq[ResponseType]] = None,
    redirectUris: Option[Seq[String]] = None,
    authorizationSignAlg: Option[JwsAlg] = None,
    authorizationEncryptionAlg: Option[JweAlg] = None,
    authorizationEncryptionEnc: Option[JweEnc] = None,
    tokenAuthMethod: Option[ClientAuthMethod] = None,
    tokenAuthSignAlg: Option[JwsAlg] = None,
    selfSignedCertificateKeyId: Option[String] = None,
    tlsClientAuthSubjectDn: Option[String] = None,
    tlsClientAuthSanDns: Option[String] = None,
    tlsClientAuthSanUri: Option[String] = None,
    tlsClientAuthSanIp: Option[String] = None,
    tlsClientAuthSanEmail: Option[String] = None,
    parRequired: Option[Boolean] = None,
    requestObjectRequired: Option[Boolean] = None,
    requestSignAlg: Option[JwsAlg] = None,
    requestEncryptionAlg: Option[JweAlg] = None,
    requestEncryptionEnc: Option[JweEnc] = None,
    requestUris: Option[Seq[String]] = None,
    defaultMaxAge: Option[Int] = None,
    defaultAcrs: Option[Seq[String]] = None,
    idTokenSignAlg: Option[JwsAlg] = None,
    idTokenEncryptionAlg: Option[JweAlg] = None,
    idTokenEncryptionEnc: Option[JweEnc] = None,
    authTimeRequired: Option[Boolean] = None,
    subjectType: Option[SubjectType] = None,
    sectorIdentifierUri: Option[String] = None,
    derivedSectorIdentifier: Option[String] = None,
    jwksUri: Option[String] = None,
    jwks: Option[String] = None,
    userInfoSignAlg: Option[JwsAlg] = None,
    userInfoEncryptionAlg: Option[JweAlg] = None,
    userInfoEncryptionEnc: Option[JweEnc] = None,
    loginUri: Option[String] = None,
    tosUri: Option[String] = None,
    tosUris: Option[Seq[TaggedValue]] = None,
    policyUri: Option[String] = None,
    policyUris: Option[Seq[TaggedValue]] = None,
    clientUri: Option[String] = None,
    clientUris: Option[Seq[TaggedValue]] = None,
    bcDeliveryMode: Option[String] = None,
    bcNotificationEndpoint: Option[String] = None,
    bcRequestSignAlg: Option[JwsAlg] = None,
    bcUserCodeRequired: Option[Boolean] = None,
    attributes: Option[Seq[Pair]] = None,
    extension: Option[ClientExtension] = None,
    authorizationDetailsTypes: Option[Seq[String]] = None,
    customMetadata: Option[String] = None,
    frontChannelRequestObjectEncryptionRequired: Option[Boolean] = None,
    requestObjectEncryptionAlgMatchRequired: Option[Boolean] = None,
    requestObjectEncryptionEncMatchRequired: Option[Boolean] = None,
    digestAlgorithm: Option[String] = None,
    singleAccessTokenPerSubject: Option[Boolean] = None,
    pkceRequired: Option[Boolean] = None,
    pkceS256Required: Option[Boolean] = None,
    dpopRequired: Option[Boolean] = None,
    automaticallyRegistered: Option[Boolean] = None,
    explicitlyRegistered: Option[Boolean] = None,
    rsRequestSigned: Option[Boolean] = None,
    rsSignedRequestKeyId: Option[String] = None,
    clientRegistrationTypes: Option[Seq[ClientRegistrationType]] = None,
    organizationName: Option[String] = None,
    signedJwksUri: Option[String] = None,
    entityId: Option[String] = None,
    trustAnchorId: Option[String] = None,
    trustChain: Option[Seq[String]] = None,
    trustChainExpiresAt: Option[Long] = None,
    trustChainUpdatedAt: Option[Long] = None,
    locked: Option[Boolean] = None
)

object Client {

  given jsonCodec: JsonValueCodec[Client] = JsonCodecMaker.make(codecMakerConfig)

  given encoderClient: Encoder[Client] = Encoder.instance { t =>
    Json.fromFields {
      Seq(
        t.number.map(v => "number" -> v.asJson),
        t.serviceNumber.map(v => "serviceNumber" -> v.asJson),
        t.developer.map(v => "developer" -> v.asJson),
        t.clientName.map(v => "clientName" -> v.asJson),
        t.clientNames.map(v => "clientNames" -> v.asJson),
        t.description.map(v => "description" -> v.asJson),
        t.descriptions.map(v => "descriptions" -> v.asJson),
        t.clientId.map(v => "clientId" -> v.asJson),
        t.clientSecret.map(v => "clientSecret" -> v.asJson),
        t.clientIdAlias.map(v => "clientIdAlias" -> v.asJson),
        t.clientIdAliasEnabled.map(v => "clientIdAliasEnabled" -> v.asJson),
        t.clientType.map(v => "clientType" -> v.asJson),
        t.applicationType.map(v => "applicationType" -> v.asJson),
        t.logoUri.map(v => "logoUri" -> v.asJson),
        t.logoUris.map(v => "logoUris" -> v.asJson),
        t.contacts.map(v => "contacts" -> v.asJson),
        t.tlsClientCertificateBoundAccessTokens
          .map(v => "tlsClientCertificateBoundAccessTokens" -> v.asJson),
        t.dynamicallyRegistered.map(v => "dynamicallyRegistered" -> v.asJson),
        t.softwareId.map(v => "softwareId" -> v.asJson),
        t.softwareVersion.map(v => "softwareVersion" -> v.asJson),
        t.registrationAccessTokenHash.map(v => "registrationAccessTokenHash" -> v.asJson),
        t.createdAt.map(v => "createdAt" -> v.asJson),
        t.modifiedAt.map(v => "modifiedAt" -> v.asJson),
        t.grantTypes.map(v => "grantTypes" -> v.asJson),
        t.responseTypes.map(v => "responseTypes" -> v.asJson),
        t.redirectUris.map(v => "redirectUris" -> v.asJson),
        t.authorizationSignAlg.map(v => "authorizationSignAlg" -> v.asJson),
        t.authorizationEncryptionAlg.map(v => "authorizationEncryptionAlg" -> v.asJson),
        t.authorizationEncryptionEnc.map(v => "authorizationEncryptionEnc" -> v.asJson),
        t.tokenAuthMethod.map(v => "tokenAuthMethod" -> v.asJson),
        t.tokenAuthSignAlg.map(v => "tokenAuthSignAlg" -> v.asJson),
        t.selfSignedCertificateKeyId.map(v => "selfSignedCertificateKeyId" -> v.asJson),
        t.tlsClientAuthSubjectDn.map(v => "tlsClientAuthSubjectDn" -> v.asJson),
        t.tlsClientAuthSanDns.map(v => "tlsClientAuthSanDns" -> v.asJson),
        t.tlsClientAuthSanUri.map(v => "tlsClientAuthSanUri" -> v.asJson),
        t.tlsClientAuthSanIp.map(v => "tlsClientAuthSanIp" -> v.asJson),
        t.tlsClientAuthSanEmail.map(v => "tlsClientAuthSanEmail" -> v.asJson),
        t.parRequired.map(v => "parRequired" -> v.asJson),
        t.requestObjectRequired.map(v => "requestObjectRequired" -> v.asJson),
        t.requestSignAlg.map(v => "requestSignAlg" -> v.asJson),
        t.requestEncryptionAlg.map(v => "requestEncryptionAlg" -> v.asJson),
        t.requestEncryptionEnc.map(v => "requestEncryptionEnc" -> v.asJson),
        t.requestUris.map(v => "requestUris" -> v.asJson),
        t.defaultMaxAge.map(v => "defaultMaxAge" -> v.asJson),
        t.defaultAcrs.map(v => "defaultAcrs" -> v.asJson),
        t.idTokenSignAlg.map(v => "idTokenSignAlg" -> v.asJson),
        t.idTokenEncryptionAlg.map(v => "idTokenEncryptionAlg" -> v.asJson),
        t.idTokenEncryptionEnc.map(v => "idTokenEncryptionEnc" -> v.asJson),
        t.authTimeRequired.map(v => "authTimeRequired" -> v.asJson),
        t.subjectType.map(v => "subjectType" -> v.asJson),
        t.sectorIdentifierUri.map(v => "sectorIdentifierUri" -> v.asJson),
        t.derivedSectorIdentifier.map(v => "derivedSectorIdentifier" -> v.asJson),
        t.jwksUri.map(v => "jwksUri" -> v.asJson),
        t.jwks.map(v => "jwks" -> v.asJson),
        t.userInfoSignAlg.map(v => "userInfoSignAlg" -> v.asJson),
        t.userInfoEncryptionAlg.map(v => "userInfoEncryptionAlg" -> v.asJson),
        t.userInfoEncryptionEnc.map(v => "userInfoEncryptionEnc" -> v.asJson),
        t.loginUri.map(v => "loginUri" -> v.asJson),
        t.tosUri.map(v => "tosUri" -> v.asJson),
        t.tosUris.map(v => "tosUris" -> v.asJson),
        t.policyUri.map(v => "policyUri" -> v.asJson),
        t.policyUris.map(v => "policyUris" -> v.asJson),
        t.clientUri.map(v => "clientUri" -> v.asJson),
        t.clientUris.map(v => "clientUris" -> v.asJson),
        t.bcDeliveryMode.map(v => "bcDeliveryMode" -> v.asJson),
        t.bcNotificationEndpoint.map(v => "bcNotificationEndpoint" -> v.asJson),
        t.bcRequestSignAlg.map(v => "bcRequestSignAlg" -> v.asJson),
        t.bcUserCodeRequired.map(v => "bcUserCodeRequired" -> v.asJson),
        t.attributes.map(v => "attributes" -> v.asJson),
        t.extension.map(v => "extension" -> v.asJson),
        t.authorizationDetailsTypes.map(v => "authorizationDetailsTypes" -> v.asJson),
        t.customMetadata.map(v => "customMetadata" -> v.asJson),
        t.frontChannelRequestObjectEncryptionRequired
          .map(v => "frontChannelRequestObjectEncryptionRequired" -> v.asJson),
        t.requestObjectEncryptionAlgMatchRequired
          .map(v => "requestObjectEncryptionAlgMatchRequired" -> v.asJson),
        t.requestObjectEncryptionEncMatchRequired
          .map(v => "requestObjectEncryptionEncMatchRequired" -> v.asJson),
        t.digestAlgorithm.map(v => "digestAlgorithm" -> v.asJson),
        t.singleAccessTokenPerSubject.map(v => "singleAccessTokenPerSubject" -> v.asJson),
        t.pkceRequired.map(v => "pkceRequired" -> v.asJson),
        t.pkceS256Required.map(v => "pkceS256Required" -> v.asJson),
        t.dpopRequired.map(v => "dpopRequired" -> v.asJson),
        t.automaticallyRegistered.map(v => "automaticallyRegistered" -> v.asJson),
        t.explicitlyRegistered.map(v => "explicitlyRegistered" -> v.asJson),
        t.rsRequestSigned.map(v => "rsRequestSigned" -> v.asJson),
        t.rsSignedRequestKeyId.map(v => "rsSignedRequestKeyId" -> v.asJson),
        t.clientRegistrationTypes.map(v => "clientRegistrationTypes" -> v.asJson),
        t.organizationName.map(v => "organizationName" -> v.asJson),
        t.signedJwksUri.map(v => "signedJwksUri" -> v.asJson),
        t.entityId.map(v => "entityId" -> v.asJson),
        t.trustAnchorId.map(v => "trustAnchorId" -> v.asJson),
        t.trustChain.map(v => "trustChain" -> v.asJson),
        t.trustChainExpiresAt.map(v => "trustChainExpiresAt" -> v.asJson),
        t.trustChainUpdatedAt.map(v => "trustChainUpdatedAt" -> v.asJson),
        t.locked.map(v => "locked" -> v.asJson)
      ).flatten
    }
  }

  given decoderClient: Decoder[Client] = Decoder.instance { c =>
    for {
      number               <- c.downField("number").as[Option[Int]]
      serviceNumber        <- c.downField("serviceNumber").as[Option[Int]]
      developer            <- c.downField("developer").as[Option[String]]
      clientName           <- c.downField("clientName").as[Option[String]]
      clientNames          <- c.downField("clientNames").as[Option[Seq[TaggedValue]]]
      description          <- c.downField("description").as[Option[String]]
      descriptions         <- c.downField("descriptions").as[Option[Seq[TaggedValue]]]
      clientId             <- c.downField("clientId").as[Option[Long]]
      clientSecret         <- c.downField("clientSecret").as[Option[String]]
      clientIdAlias        <- c.downField("clientIdAlias").as[Option[String]]
      clientIdAliasEnabled <- c.downField("clientIdAliasEnabled").as[Option[Boolean]]
      clientType           <- mapEmptyStringToNull(c.downField("clientType")).as[Option[ClientType]]
      applicationType <-
        mapEmptyStringToNull(c.downField("applicationType")).as[Option[ApplicationType]]
      logoUri  <- c.downField("logoUri").as[Option[String]]
      logoUris <- c.downField("logoUris").as[Option[Seq[TaggedValue]]]
      contacts <- c.downField("contacts").as[Option[Seq[String]]]
      tlsClientCertificateBoundAccessTokens <-
        c.downField("tlsClientCertificateBoundAccessTokens").as[Option[Boolean]]
      dynamicallyRegistered       <- c.downField("dynamicallyRegistered").as[Option[Boolean]]
      softwareId                  <- c.downField("softwareId").as[Option[String]]
      softwareVersion             <- c.downField("softwareVersion").as[Option[String]]
      registrationAccessTokenHash <- c.downField("registrationAccessTokenHash").as[Option[String]]
      createdAt                   <- c.downField("createdAt").as[Option[Long]]
      modifiedAt                  <- c.downField("modifiedAt").as[Option[Long]]
      grantTypes                  <- c.downField("grantTypes").as[Option[Seq[GrantType]]]
      responseTypes               <- c.downField("responseTypes").as[Option[Seq[ResponseType]]]
      redirectUris                <- c.downField("redirectUris").as[Option[Seq[String]]]
      authorizationSignAlg <-
        mapEmptyStringToNull(c.downField("authorizationSignAlg")).as[Option[JwsAlg]]
      authorizationEncryptionAlg <- mapEmptyStringToNull(c.downField("authorizationEncryptionAlg"))
                                      .as[Option[JweAlg]]
      authorizationEncryptionEnc <- mapEmptyStringToNull(c.downField("authorizationEncryptionEnc"))
                                      .as[Option[JweEnc]]
      tokenAuthMethod <-
        mapEmptyStringToNull(c.downField("tokenAuthMethod")).as[Option[ClientAuthMethod]]
      tokenAuthSignAlg           <- mapEmptyStringToNull(c.downField("tokenAuthSignAlg")).as[Option[JwsAlg]]
      selfSignedCertificateKeyId <- c.downField("selfSignedCertificateKeyId").as[Option[String]]
      tlsClientAuthSubjectDn     <- c.downField("tlsClientAuthSubjectDn").as[Option[String]]
      tlsClientAuthSanDns        <- c.downField("tlsClientAuthSanDns").as[Option[String]]
      tlsClientAuthSanUri        <- c.downField("tlsClientAuthSanUri").as[Option[String]]
      tlsClientAuthSanIp         <- c.downField("tlsClientAuthSanIp").as[Option[String]]
      tlsClientAuthSanEmail      <- c.downField("tlsClientAuthSanEmail").as[Option[String]]
      parRequired                <- c.downField("parRequired").as[Option[Boolean]]
      requestObjectRequired      <- c.downField("requestObjectRequired").as[Option[Boolean]]
      requestSignAlg             <- mapEmptyStringToNull(c.downField("requestSignAlg")).as[Option[JwsAlg]]
      requestEncryptionAlg <-
        mapEmptyStringToNull(c.downField("requestEncryptionAlg")).as[Option[JweAlg]]
      requestEncryptionEnc <-
        mapEmptyStringToNull(c.downField("requestEncryptionEnc")).as[Option[JweEnc]]
      requestUris    <- c.downField("requestUris").as[Option[Seq[String]]]
      defaultMaxAge  <- c.downField("defaultMaxAge").as[Option[Int]]
      defaultAcrs    <- c.downField("defaultAcrs").as[Option[Seq[String]]]
      idTokenSignAlg <- mapEmptyStringToNull(c.downField("idTokenSignAlg")).as[Option[JwsAlg]]
      idTokenEncryptionAlg <-
        mapEmptyStringToNull(c.downField("idTokenEncryptionAlg")).as[Option[JweAlg]]
      idTokenEncryptionEnc <-
        mapEmptyStringToNull(c.downField("idTokenEncryptionEnc")).as[Option[JweEnc]]
      authTimeRequired        <- c.downField("authTimeRequired").as[Option[Boolean]]
      subjectType             <- mapEmptyStringToNull(c.downField("subjectType")).as[Option[SubjectType]]
      sectorIdentifierUri     <- c.downField("sectorIdentifierUri").as[Option[String]]
      derivedSectorIdentifier <- c.downField("derivedSectorIdentifier").as[Option[String]]
      jwksUri                 <- c.downField("jwksUri").as[Option[String]]
      jwks                    <- c.downField("jwks").as[Option[String]]
      userInfoSignAlg         <- mapEmptyStringToNull(c.downField("userInfoSignAlg")).as[Option[JwsAlg]]
      userInfoEncryptionAlg <-
        mapEmptyStringToNull(c.downField("userInfoEncryptionAlg")).as[Option[JweAlg]]
      userInfoEncryptionEnc <-
        mapEmptyStringToNull(c.downField("userInfoEncryptionEnc")).as[Option[JweEnc]]
      loginUri                  <- c.downField("loginUri").as[Option[String]]
      tosUri                    <- c.downField("tosUri").as[Option[String]]
      tosUris                   <- c.downField("tosUris").as[Option[Seq[TaggedValue]]]
      policyUri                 <- c.downField("policyUri").as[Option[String]]
      policyUris                <- c.downField("policyUris").as[Option[Seq[TaggedValue]]]
      clientUri                 <- c.downField("clientUri").as[Option[String]]
      clientUris                <- c.downField("clientUris").as[Option[Seq[TaggedValue]]]
      bcDeliveryMode            <- c.downField("bcDeliveryMode").as[Option[String]]
      bcNotificationEndpoint    <- c.downField("bcNotificationEndpoint").as[Option[String]]
      bcRequestSignAlg          <- mapEmptyStringToNull(c.downField("bcRequestSignAlg")).as[Option[JwsAlg]]
      bcUserCodeRequired        <- c.downField("bcUserCodeRequired").as[Option[Boolean]]
      attributes                <- c.downField("attributes").as[Option[Seq[Pair]]]
      extension                 <- c.downField("extension").as[Option[ClientExtension]]
      authorizationDetailsTypes <- c.downField("authorizationDetailsTypes").as[Option[Seq[String]]]
      customMetadata            <- c.downField("customMetadata").as[Option[String]]
      frontChannelRequestObjectEncryptionRequired <-
        c.downField("frontChannelRequestObjectEncryptionRequired").as[Option[Boolean]]
      requestObjectEncryptionAlgMatchRequired <-
        c.downField("requestObjectEncryptionAlgMatchRequired").as[Option[Boolean]]
      requestObjectEncryptionEncMatchRequired <-
        c.downField("requestObjectEncryptionEncMatchRequired").as[Option[Boolean]]
      digestAlgorithm             <- c.downField("digestAlgorithm").as[Option[String]]
      singleAccessTokenPerSubject <- c.downField("singleAccessTokenPerSubject").as[Option[Boolean]]
      pkceRequired                <- c.downField("pkceRequired").as[Option[Boolean]]
      pkceS256Required            <- c.downField("pkceS256Required").as[Option[Boolean]]
      dpopRequired                <- c.downField("dpopRequired").as[Option[Boolean]]
      automaticallyRegistered     <- c.downField("automaticallyRegistered").as[Option[Boolean]]
      explicitlyRegistered        <- c.downField("explicitlyRegistered").as[Option[Boolean]]
      rsRequestSigned             <- c.downField("rsRequestSigned").as[Option[Boolean]]
      rsSignedRequestKeyId        <- c.downField("rsSignedRequestKeyId").as[Option[String]]
      clientRegistrationTypes <-
        c.downField("clientRegistrationTypes").as[Option[Seq[ClientRegistrationType]]]
      organizationName    <- c.downField("organizationName").as[Option[String]]
      signedJwksUri       <- c.downField("signedJwksUri").as[Option[String]]
      entityId            <- c.downField("entityId").as[Option[String]]
      trustAnchorId       <- c.downField("trustAnchorId").as[Option[String]]
      trustChain          <- c.downField("trustChain").as[Option[Seq[String]]]
      trustChainExpiresAt <- c.downField("trustChainExpiresAt").as[Option[Long]]
      trustChainUpdatedAt <- c.downField("trustChainUpdatedAt").as[Option[Long]]
      locked              <- c.downField("locked").as[Option[Boolean]]
    } yield Client(
      number = number,
      serviceNumber = serviceNumber,
      developer = developer,
      clientName = clientName,
      clientNames = clientNames,
      description = description,
      descriptions = descriptions,
      clientId = clientId,
      clientSecret = clientSecret,
      clientIdAlias = clientIdAlias,
      clientIdAliasEnabled = clientIdAliasEnabled,
      clientType = clientType,
      applicationType = applicationType,
      logoUri = logoUri,
      logoUris = logoUris,
      contacts = contacts,
      tlsClientCertificateBoundAccessTokens = tlsClientCertificateBoundAccessTokens,
      dynamicallyRegistered = dynamicallyRegistered,
      softwareId = softwareId,
      softwareVersion = softwareVersion,
      registrationAccessTokenHash = registrationAccessTokenHash,
      createdAt = createdAt,
      modifiedAt = modifiedAt,
      grantTypes = grantTypes,
      responseTypes = responseTypes,
      redirectUris = redirectUris,
      authorizationSignAlg = authorizationSignAlg,
      authorizationEncryptionAlg = authorizationEncryptionAlg,
      authorizationEncryptionEnc = authorizationEncryptionEnc,
      tokenAuthMethod = tokenAuthMethod,
      tokenAuthSignAlg = tokenAuthSignAlg,
      selfSignedCertificateKeyId = selfSignedCertificateKeyId,
      tlsClientAuthSubjectDn = tlsClientAuthSubjectDn,
      tlsClientAuthSanDns = tlsClientAuthSanDns,
      tlsClientAuthSanUri = tlsClientAuthSanUri,
      tlsClientAuthSanIp = tlsClientAuthSanIp,
      tlsClientAuthSanEmail = tlsClientAuthSanEmail,
      parRequired = parRequired,
      requestObjectRequired = requestObjectRequired,
      requestSignAlg = requestSignAlg,
      requestEncryptionAlg = requestEncryptionAlg,
      requestEncryptionEnc = requestEncryptionEnc,
      requestUris = requestUris,
      defaultMaxAge = defaultMaxAge,
      defaultAcrs = defaultAcrs,
      idTokenSignAlg = idTokenSignAlg,
      idTokenEncryptionAlg = idTokenEncryptionAlg,
      idTokenEncryptionEnc = idTokenEncryptionEnc,
      authTimeRequired = authTimeRequired,
      subjectType = subjectType,
      sectorIdentifierUri = sectorIdentifierUri,
      derivedSectorIdentifier = derivedSectorIdentifier,
      jwksUri = jwksUri,
      jwks = jwks,
      userInfoSignAlg = userInfoSignAlg,
      userInfoEncryptionAlg = userInfoEncryptionAlg,
      userInfoEncryptionEnc = userInfoEncryptionEnc,
      loginUri = loginUri,
      tosUri = tosUri,
      tosUris = tosUris,
      policyUri = policyUri,
      policyUris = policyUris,
      clientUri = clientUri,
      clientUris = clientUris,
      bcDeliveryMode = bcDeliveryMode,
      bcNotificationEndpoint = bcNotificationEndpoint,
      bcRequestSignAlg = bcRequestSignAlg,
      bcUserCodeRequired = bcUserCodeRequired,
      attributes = attributes,
      extension = extension,
      authorizationDetailsTypes = authorizationDetailsTypes,
      customMetadata = customMetadata,
      frontChannelRequestObjectEncryptionRequired = frontChannelRequestObjectEncryptionRequired,
      requestObjectEncryptionAlgMatchRequired = requestObjectEncryptionAlgMatchRequired,
      requestObjectEncryptionEncMatchRequired = requestObjectEncryptionEncMatchRequired,
      digestAlgorithm = digestAlgorithm,
      singleAccessTokenPerSubject = singleAccessTokenPerSubject,
      pkceRequired = pkceRequired,
      pkceS256Required = pkceS256Required,
      dpopRequired = dpopRequired,
      automaticallyRegistered = automaticallyRegistered,
      explicitlyRegistered = explicitlyRegistered,
      rsRequestSigned = rsRequestSigned,
      rsSignedRequestKeyId = rsSignedRequestKeyId,
      clientRegistrationTypes = clientRegistrationTypes,
      organizationName = organizationName,
      signedJwksUri = signedJwksUri,
      entityId = entityId,
      trustAnchorId = trustAnchorId,
      trustChain = trustChain,
      trustChainExpiresAt = trustChainExpiresAt,
      trustChainUpdatedAt = trustChainUpdatedAt,
      locked = locked
    )
  }

}
