/**
  * Authlete API Authlete API Document.
  *
  * The version of the OpenAPI document: 2.3.12 Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package authlete
package models

import scala.collection.immutable.Seq

///import authlete.models.UserInfoRequest
import com.github.plokhotnyuk.jsoniter_scala.core.JsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.ConfiguredJsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMaker
import io.circe.{Decoder, Encoder, Json}
import io.circe.syntax.*

/**
  * @param token
  *   The access token that has been passed to the userinfo endpoint by the client application. In
  *   other words, the access token which was contained in the userinfo request.
  * @param claims
  *   Claims in JSON format. As for the format, see [OpenID Connect Core 1.0, 5.1. Standard
  *   Claims](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims).
  * @param sub
  *   The value of the `sub` claim. If the value of this request parameter is not empty, it is used
  *   as the value of the `sub` claim. Otherwise, the value of the subject associated with the
  *   access token is used.
  * @param claimsForTx
  *   Claim key-value pairs that are used to compute transformed claims.
  * @param requestSignature
  *   The Signature header value from the request.
  * @param headers
  *   HTTP headers to be included in processing the signature. If this is a signed request, this
  *   must include the Signature and Signature-Input headers, as well as any additional headers
  *   covered by the signature.
  */
case class UserinfoIssueRequest(
    token: String,
    claims: Option[String] = None,
    sub: Option[String] = None,
    claimsForTx: Option[String] = None,
    requestSignature: Option[String] = None,
    headers: Option[Seq[Pair]] = None
)

object UserinfoIssueRequest {

  given jsonCodec: JsonValueCodec[UserinfoIssueRequest] =
    JsonCodecMaker.make(codecMakerConfig)

  given encoderUserinfoIssueRequest: Encoder[UserinfoIssueRequest] = Encoder.instance { t =>
    Json.fromFields {
      Seq(
        Some("token" -> t.token.asJson),
        t.claims.map(v => "claims" -> v.asJson),
        t.sub.map(v => "sub" -> v.asJson),
        t.claimsForTx.map(v => "claimsForTx" -> v.asJson),
        t.requestSignature.map(v => "requestSignature" -> v.asJson),
        t.headers.map(v => "headers" -> v.asJson)
      ).flatten
    }
  }

  given decoderUserinfoIssueRequest: Decoder[UserinfoIssueRequest] = Decoder.instance { c =>
    for {
      token            <- c.downField("token").as[String]
      claims           <- c.downField("claims").as[Option[String]]
      sub              <- c.downField("sub").as[Option[String]]
      claimsForTx      <- c.downField("claimsForTx").as[Option[String]]
      requestSignature <- c.downField("requestSignature").as[Option[String]]
      headers          <- c.downField("headers").as[Option[Seq[Pair]]]
    } yield UserinfoIssueRequest(
      token = token,
      claims = claims,
      sub = sub,
      claimsForTx = claimsForTx,
      requestSignature = requestSignature,
      headers = headers
    )
  }

}
