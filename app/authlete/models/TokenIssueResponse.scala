/**
  * Authlete API Authlete API Document.
  *
  * The version of the OpenAPI document: 2.3.12 Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package authlete
package models

import scala.collection.immutable.Seq

import com.github.plokhotnyuk.jsoniter_scala.core.JsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.ConfiguredJsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMaker
import io.circe.{Decoder, Encoder, Json}
import io.circe.syntax.*

/**
  * @param resultCode
  *   The code which represents the result of the API call.
  * @param resultMessage
  *   A short message which explains the result of the API call.
  * @param action
  * @param responseContent
  *   The content that the authorization server implementation is to return to the client
  *   application. Its format is JSON.
  * @param accessToken
  *   The newly issued access token. This parameter is a non-null value only when the value of
  *   `action` parameter is `OK`.
  * @param accessTokenExpiresAt
  *   The datetime at which the newly issued access token will expire. The value is represented in
  *   milliseconds since the Unix epoch (1970-01-01).
  * @param accessTokenDuration
  *   The duration of the newly issued access token in seconds.
  * @param refreshToken
  *   The refresh token. This parameter is a non-null value only when `action` is `OK` and the
  *   service supports the refresh token flow. If `refreshTokenKept` is set to `false`, a new
  *   refresh token is issued and the old refresh token used in the refresh token flow is
  *   invalidated. On the contrary, if `refreshTokenKept` is set to `true`, the refresh token itself
  *   is not refreshed.
  * @param refreshTokenExpiresAt
  *   The datetime at which the newly issued refresh token will expire. The value is represented in
  *   milliseconds since the Unix epoch (1970-01-01).
  * @param refreshTokenDuration
  *   The duration of the newly issued refresh token in seconds.
  * @param clientId
  *   The client ID.
  * @param clientIdAlias
  *   The client ID alias. If the client did not have an alias, this parameter is `null`.
  * @param clientIdAliasUsed
  *   The flag which indicates whether the client ID alias was used when the token request was made.
  *   `true` if the client ID alias was used when the token request was made.
  * @param subject
  *   The subject (= resource owner's ID) of the access token. Even if an access token has been
  *   issued by calling `/api/auth/token` API, this parameter is `null` if the flow of the token
  *   request was [Client Credentials
  *   Flow](https://datatracker.ietf.org/doc/html/rfc6749#section-4.4)
  *   (`grant_type=client_credentials`) because it means the access token is not associated with any
  *   specific end-user.
  * @param scopes
  *   The scopes covered by the access token.
  * @param properties
  *   The extra properties associated with the access token. This parameter is `null` when no extra
  *   property is associated with the issued access token.
  * @param jwtAccessToken
  *   The newly issued access token in JWT format. If the authorization server is configured to
  *   issue JWT-based access tokens (= if the service's `accessTokenSignAlg` value is a non-null
  *   value), a JWT-based access token is issued along with the original random-string one.
  * @param accessTokenResources
  *   The target resources of the access token being issued. See \"Resource Indicators for OAuth
  *   2.0\" for details.
  * @param authorizationDetails
  * @param serviceAttributes
  *   The attributes of this service that the client application belongs to.
  * @param clientAttributes
  *   The attributes of the client.
  * @param clientEntityId
  *   The entity ID of the client.
  * @param clientEntityIdUsed
  *   Flag which indicates whether the entity ID of the client was used when the request for the
  *   access token was made.
  */
case class TokenIssueResponse(
    resultCode: Option[String] = None,
    resultMessage: Option[String] = None,
    action: Option[TokenIssueResponseAction] = None,
    responseContent: Option[String] = None,
    accessToken: Option[String] = None,
    accessTokenExpiresAt: Option[Long] = None,
    accessTokenDuration: Option[Long] = None,
    refreshToken: Option[String] = None,
    refreshTokenExpiresAt: Option[Long] = None,
    refreshTokenDuration: Option[Long] = None,
    clientId: Option[Long] = None,
    clientIdAlias: Option[String] = None,
    clientIdAliasUsed: Option[Boolean] = None,
    subject: Option[String] = None,
    scopes: Option[Seq[String]] = None,
    properties: Option[Seq[Property]] = None,
    jwtAccessToken: Option[String] = None,
    accessTokenResources: Option[Seq[String]] = None,
    authorizationDetails: Option[AuthzDetails] = None,
    serviceAttributes: Option[Seq[Pair]] = None,
    clientAttributes: Option[Seq[Pair]] = None,
    clientEntityId: Option[String] = None,
    clientEntityIdUsed: Option[Boolean] = None
)

object TokenIssueResponse {

  given jsonCodec: JsonValueCodec[TokenIssueResponse] = JsonCodecMaker.make(codecMakerConfig)

  given encoderTokenIssueResponse: Encoder[TokenIssueResponse] = Encoder.instance { t =>
    Json.fromFields {
      Seq(
        t.resultCode.map(v => "resultCode" -> v.asJson),
        t.resultMessage.map(v => "resultMessage" -> v.asJson),
        t.action.map(v => "action" -> v.asJson),
        t.responseContent.map(v => "responseContent" -> v.asJson),
        t.accessToken.map(v => "accessToken" -> v.asJson),
        t.accessTokenExpiresAt.map(v => "accessTokenExpiresAt" -> v.asJson),
        t.accessTokenDuration.map(v => "accessTokenDuration" -> v.asJson),
        t.refreshToken.map(v => "refreshToken" -> v.asJson),
        t.refreshTokenExpiresAt.map(v => "refreshTokenExpiresAt" -> v.asJson),
        t.refreshTokenDuration.map(v => "refreshTokenDuration" -> v.asJson),
        t.clientId.map(v => "clientId" -> v.asJson),
        t.clientIdAlias.map(v => "clientIdAlias" -> v.asJson),
        t.clientIdAliasUsed.map(v => "clientIdAliasUsed" -> v.asJson),
        t.subject.map(v => "subject" -> v.asJson),
        t.scopes.map(v => "scopes" -> v.asJson),
        t.properties.map(v => "properties" -> v.asJson),
        t.jwtAccessToken.map(v => "jwtAccessToken" -> v.asJson),
        t.accessTokenResources.map(v => "accessTokenResources" -> v.asJson),
        t.authorizationDetails.map(v => "authorizationDetails" -> v.asJson),
        t.serviceAttributes.map(v => "serviceAttributes" -> v.asJson),
        t.clientAttributes.map(v => "clientAttributes" -> v.asJson),
        t.clientEntityId.map(v => "clientEntityId" -> v.asJson),
        t.clientEntityIdUsed.map(v => "clientEntityIdUsed" -> v.asJson)
      ).flatten
    }
  }

  given decoderTokenIssueResponse: Decoder[TokenIssueResponse] = Decoder.instance { c =>
    for {
      resultCode            <- c.downField("resultCode").as[Option[String]]
      resultMessage         <- c.downField("resultMessage").as[Option[String]]
      action                <- mapEmptyStringToNull(c.downField("action")).as[Option[TokenIssueResponseAction]]
      responseContent       <- c.downField("responseContent").as[Option[String]]
      accessToken           <- c.downField("accessToken").as[Option[String]]
      accessTokenExpiresAt  <- c.downField("accessTokenExpiresAt").as[Option[Long]]
      accessTokenDuration   <- c.downField("accessTokenDuration").as[Option[Long]]
      refreshToken          <- c.downField("refreshToken").as[Option[String]]
      refreshTokenExpiresAt <- c.downField("refreshTokenExpiresAt").as[Option[Long]]
      refreshTokenDuration  <- c.downField("refreshTokenDuration").as[Option[Long]]
      clientId              <- c.downField("clientId").as[Option[Long]]
      clientIdAlias         <- c.downField("clientIdAlias").as[Option[String]]
      clientIdAliasUsed     <- c.downField("clientIdAliasUsed").as[Option[Boolean]]
      subject               <- c.downField("subject").as[Option[String]]
      scopes                <- c.downField("scopes").as[Option[Seq[String]]]
      properties            <- c.downField("properties").as[Option[Seq[Property]]]
      jwtAccessToken        <- c.downField("jwtAccessToken").as[Option[String]]
      accessTokenResources  <- c.downField("accessTokenResources").as[Option[Seq[String]]]
      authorizationDetails  <- c.downField("authorizationDetails").as[Option[AuthzDetails]]
      serviceAttributes     <- c.downField("serviceAttributes").as[Option[Seq[Pair]]]
      clientAttributes      <- c.downField("clientAttributes").as[Option[Seq[Pair]]]
      clientEntityId        <- c.downField("clientEntityId").as[Option[String]]
      clientEntityIdUsed    <- c.downField("clientEntityIdUsed").as[Option[Boolean]]
    } yield TokenIssueResponse(
      resultCode = resultCode,
      resultMessage = resultMessage,
      action = action,
      responseContent = responseContent,
      accessToken = accessToken,
      accessTokenExpiresAt = accessTokenExpiresAt,
      accessTokenDuration = accessTokenDuration,
      refreshToken = refreshToken,
      refreshTokenExpiresAt = refreshTokenExpiresAt,
      refreshTokenDuration = refreshTokenDuration,
      clientId = clientId,
      clientIdAlias = clientIdAlias,
      clientIdAliasUsed = clientIdAliasUsed,
      subject = subject,
      scopes = scopes,
      properties = properties,
      jwtAccessToken = jwtAccessToken,
      accessTokenResources = accessTokenResources,
      authorizationDetails = authorizationDetails,
      serviceAttributes = serviceAttributes,
      clientAttributes = clientAttributes,
      clientEntityId = clientEntityId,
      clientEntityIdUsed = clientEntityIdUsed
    )
  }

}
