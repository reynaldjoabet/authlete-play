/**
  * Authlete API Authlete API Document.
  *
  * The version of the OpenAPI document: 2.3.12 Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package authlete
package models

import com.github.plokhotnyuk.jsoniter_scala.core.JsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.ConfiguredJsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMaker
import io.circe.{Decoder, Encoder, Json}
import io.circe.syntax.*

/**
  * @param parameters
  *   The pushed authorization request body received from the client application. The value of
  *   parameters is the entire entity body (which is formatted in
  *   `application/x-www-form-urlencoded`) of the request from the client application.
  * @param clientId
  *   The client ID extracted from `Authorization` header of the pushed request from the client
  *   application.
  * @param clientSecret
  *   The client secret extracted from `Authorization` header of the pushed authorization request
  *   from the client application.
  * @param clientCertificate
  *   The client certificate from the MTLS connection to pushed authorization endpoint from the
  *   client application.
  * @param clientCertificatePath
  *   The certificate path presented by the client during client authentication. These certificates
  *   are strings in PEM format.
  * @param dpop
  *   DPoP Header
  * @param htm
  *   HTTP Method (for DPoP validation).
  * @param htu
  *   HTTP URL base (for DPoP validation).
  */
case class PushedAuthorizationRequest(
    parameters: String,
    clientId: Option[String] = None,
    clientSecret: Option[String] = None,
    clientCertificate: Option[String] = None,
    clientCertificatePath: Option[String] = None,
    dpop: Option[String] = None,
    htm: Option[String] = None,
    htu: Option[String] = None
)

object PushedAuthorizationRequest {

  given jsonCodec: JsonValueCodec[PushedAuthorizationRequest] =
    JsonCodecMaker.make(codecMakerConfig)

  given encoderPushedAuthorizationRequest: Encoder[PushedAuthorizationRequest] =
    Encoder.instance { t =>
      Json.fromFields {
        Seq(
          Some("parameters" -> t.parameters.asJson),
          t.clientId.map(v => "clientId" -> v.asJson),
          t.clientSecret.map(v => "clientSecret" -> v.asJson),
          t.clientCertificate.map(v => "clientCertificate" -> v.asJson),
          t.clientCertificatePath.map(v => "clientCertificatePath" -> v.asJson),
          t.dpop.map(v => "dpop" -> v.asJson),
          t.htm.map(v => "htm" -> v.asJson),
          t.htu.map(v => "htu" -> v.asJson)
        ).flatten
      }
    }

  given decoderPushedAuthorizationRequest: Decoder[PushedAuthorizationRequest] =
    Decoder.instance { c =>
      for {
        parameters            <- c.downField("parameters").as[String]
        clientId              <- c.downField("clientId").as[Option[String]]
        clientSecret          <- c.downField("clientSecret").as[Option[String]]
        clientCertificate     <- c.downField("clientCertificate").as[Option[String]]
        clientCertificatePath <- c.downField("clientCertificatePath").as[Option[String]]
        dpop                  <- c.downField("dpop").as[Option[String]]
        htm                   <- c.downField("htm").as[Option[String]]
        htu                   <- c.downField("htu").as[Option[String]]
      } yield PushedAuthorizationRequest(
        parameters = parameters,
        clientId = clientId,
        clientSecret = clientSecret,
        clientCertificate = clientCertificate,
        clientCertificatePath = clientCertificatePath,
        dpop = dpop,
        htm = htm,
        htu = htu
      )
    }

}
