/**
  * Authlete API Authlete API Document.
  *
  * The version of the OpenAPI document: 2.3.12 Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package authlete
package models

import java.net.URI

import scala.collection.immutable.Seq

import com.github.plokhotnyuk.jsoniter_scala.core.JsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.ConfiguredJsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMaker
import io.circe.{Decoder, Encoder, Json}
import io.circe.syntax.*

/**
  * @param number
  *   The sequential number of the service. The value of this property is assigned by Authlete.
  * @param serviceOwnerNumber
  *   The sequential number of the service owner of the service. The value of this property is
  *   assigned by Authlete.
  * @param serviceName
  *   The name of this service.
  * @param issuer
  *   The issuer identifier of the service. A URL that starts with https:// and has no query or
  *   fragment component. The value of this property is used as `iss` claim in an [ID
  *   token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken) and `issuer` property in
  *   the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param description
  *   The description about the service.
  * @param apiKey
  *   The API key. The value of this property is assigned by Authlete.
  * @param apiSecret
  *   The API secret. A random 256-bit value encoded by base64url (43 letters). The value of this
  *   property is assigned by Authlete.
  * @param clientsPerDeveloper
  *   The maximum number of client applications that a developer is allowed to create. `0` means no
  *   limit.
  * @param clientIdAliasEnabled
  *   The flag to indicate whether the 'Client ID Alias' feature is enabled or not. When a new
  *   client is created, Authlete generates a numeric value and assigns it as a client ID to the
  *   newly created client. In addition to the client ID, each client can have a client ID alias.
  *   The client ID alias is, however, recognized only when this property (`clientIdAliasEnabled`)
  *   is set to `true`.
  * @param metadata
  *   The `metadata` of the service. The content of the returned array depends on contexts. The
  *   predefined service metadata is listed in the following table. | Key | Description | | --- |
  *   --- | | `clientCount` | The number of client applications which belong to this service. |
  * @param createdAt
  *   The time at which this service was created. The value is represented as milliseconds since the
  *   UNIX epoch (`1970-01-01`).
  * @param modifiedAt
  *   The time at which this service was last modified. The value is represented as milliseconds
  *   since the UNIX epoch (1970-01-01).
  * @param authenticationCallbackEndpoint
  *   A Web API endpoint for user authentication which is to be prepared on the service side. The
  *   endpoint must be implemented if you do not implement the UI at the authorization endpoint but
  *   use the one provided by Authlete. The user authentication at the authorization endpoint
  *   provided by Authlete is performed by making a `POST` request to this endpoint.
  * @param authenticationCallbackApiKey
  *   API key for basic authentication at the authentication callback endpoint. If the value is not
  *   empty, Authlete generates Authorization header for Basic authentication when making a request
  *   to the authentication callback endpoint.
  * @param authenticationCallbackApiSecret
  *   API secret for `basic` authentication at the authentication callback endpoint.
  * @param supportedSnses
  *   SNSes you want to support 'social login' in the UI at the authorization endpoint provided by
  *   Authlete. You need to register a `client` application in each SNS that is set as this
  *   parameter and set Authlete server's `/api/sns/redirection` as the redirection endpoint of the
  *   client application.
  * @param snsCredentials
  *   `SNS` credentials which Authlete uses to make requests to SNSes. The format is JSON.
  * @param supportedAcrs
  *   Values of acrs (authentication context class references) that the service supports. The value
  *   of this property is used as `acr_values_supported` property in the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param developerAuthenticationCallbackEndpoint
  *   A Web API endpoint for developer authentication which is to be prepared on the server side.
  *   The endpoint must be implemented if you use Developer Console. The developer authentication at
  *   the login page of Developer Console is performed by making a `POST` request to this endpoint.
  * @param developerAuthenticationCallbackApiKey
  *   API key for basic authentication at the developer authentication callback endpoint. If the
  *   value is not empty, Authlete generates Authorization header for Basic authentication when
  *   making a request to the developer authentication callback endpoint.
  * @param developerAuthenticationCallbackApiSecret
  *   API secret for basic authentication at the developer authentication callback endpoint.
  * @param supportedDeveloperSnses
  *   SNSes you want to support 'social login' in the login page of Developer Console provided by
  *   Authlete. You need to register a client application in each SNS checked here and set Authlete
  *   server's `/api/developer/sns/redirection` as the redirection endpoint of the client
  *   application.
  * @param developerSnsCredentials
  *   SNS credentials which Authlete uses to make requests to SNSes. The format is JSON.
  * @param supportedGrantTypes
  *   Values of `grant_type` request parameter that the service supports. The value of this property
  *   is used as `grant_types_supported property` in the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param supportedResponseTypes
  *   Values of `response_type` request parameter that the service supports. Valid values are listed
  *   in Response Type. The value of this property is used as `response_types_supported` property in
  *   the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param supportedAuthorizationDetailsTypes
  *   The supported data types that can be used as values of the type field in
  *   `authorization_details`. This property corresponds to the
  *   `authorization_details_types_supported` metadata. See \"OAuth 2.0 Rich Authorization
  *   Requests\" (RAR) for details.
  * @param supportedServiceProfiles
  *   The profiles that this service supports.
  * @param errorDescriptionOmitted
  *   The flag to indicate whether the `error_description` response parameter is omitted. According
  *   to [RFC 6749](https://tools.ietf.org/html/rfc6749), an authorization server may include the
  *   `error_description` response parameter in error responses. If `true`, Authlete does not embed
  *   the `error_description` response parameter in error responses.
  * @param errorUriOmitted
  *   The flag to indicate whether the `error_uri` response parameter is omitted. According to [RFC
  *   6749](https://tools.ietf.org/html/rfc6749), an authorization server may include the
  *   `error_uri` response parameter in error responses. If `true`, Authlete does not embed the
  *   `error_uri` response parameter in error responses.
  * @param authorizationEndpoint
  *   The authorization endpoint of the service. A URL that starts with `https://` and has no
  *   fragment component. For example, `https://example.com/auth/authorization`. The value of this
  *   property is used as `authorization_endpoint` property in the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param directAuthorizationEndpointEnabled
  *   The flag to indicate whether the direct authorization endpoint is enabled or not. The path of
  *   the endpoint is `/api/auth/authorization/direct/service-api-key`.
  * @param supportedUiLocales
  *   UI locales that the service supports. Each element is a language tag defined in [RFC
  *   5646](https://tools.ietf.org/html/rfc5646). For example, `en-US` and `ja-JP`. The value of
  *   this property is used as `ui_locales_supported` property in the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param supportedDisplays
  *   Values of `display` request parameter that service supports. The value of this property is
  *   used as `display_values_supported` property in the Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param pkceRequired
  *   The flag to indicate whether the use of Proof Key for Code Exchange (PKCE) is always required
  *   for authorization requests by Authorization Code Flow. If `true`, `code_challenge` request
  *   parameter is always required for authorization requests using Authorization Code Flow. See
  *   [RFC 7636](https://tools.ietf.org/html/rfc7636) (Proof Key for Code Exchange by OAuth Public
  *   Clients) for details about `code_challenge` request parameter.
  * @param pkceS256Required
  *   The flag to indicate whether `S256` is always required as the code challenge method whenever
  *   [PKCE (RFC 7636)](https://tools.ietf.org/html/rfc7636) is used. If this flag is set to `true`,
  *   `code_challenge_method=S256` must be included in the authorization request whenever it
  *   includes the `code_challenge` request parameter. Neither omission of the
  *   `code_challenge_method` request parameter nor use of plain (`code_challenge_method=plain`) is
  *   allowed.
  * @param authorizationResponseDuration
  *   The duration of authorization response JWTs in seconds. [Financial-grade API: JWT Secured
  *   Authorization Response Mode for OAuth 2.0
  *   (JARM)](https://openid.net/specs/openid-financial-api-jarm.html) defines new values for the
  *   `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`, `form_post.jwt` and
  *   `jwt`. If one of them is specified as the response mode, response parameters from the
  *   authorization endpoint will be packed into a JWT. This property is used to compute the value
  *   of the `exp` claim of the JWT.
  * @param tokenEndpoint
  *   The [token endpoint](https://tools.ietf.org/html/rfc6749#section-3.2) of the service. A URL
  *   that starts with `https://` and has not fragment component. For example,
  *   `https://example.com/auth/token`. The value of this property is used as `token_endpoint`
  *   property in the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param directTokenEndpointEnabled
  *   The flag to indicate whether the direct token endpoint is enabled or not. The path of the
  *   endpoint is `/api/auth/token/direct/service-api-key`.
  * @param supportedTokenAuthMethods
  *   Client authentication methods supported by the token endpoint of the service. The value of
  *   this property is used as `token_endpoint_auth_methods_supports` property in the [OpenID
  *   Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param missingClientIdAllowed
  *   The flag to indicate token requests from public clients without the `client_id` request
  *   parameter are allowed when the client can be guessed from `authorization_code` or
  *   `refresh_token`. This flag should not be set unless you have special reasons.
  * @param revocationEndpoint
  *   The [revocation endpoint](https://tools.ietf.org/html/rfc7009) of the service. A URL that
  *   starts with `https://`. For example, `https://example.com/auth/revocation`.
  * @param directRevocationEndpointEnabled
  *   The flag to indicate whether the direct revocation endpoint is enabled or not. The URL of the
  *   endpoint is `/api/auth/revocation/direct/service-api-key`.
  * @param supportedRevocationAuthMethods
  *   Client authentication methods supported at the revocation endpoint.
  * @param introspectionEndpoint
  *   The URI of the introspection endpoint.
  * @param directIntrospectionEndpointEnabled
  *   The flag to indicate whether the direct userinfo endpoint is enabled or not. The path of the
  *   endpoint is `/api/auth/userinfo/direct/{serviceApiKey}`.
  * @param supportedIntrospectionAuthMethods
  *   Client authentication methods supported at the introspection endpoint.
  * @param pushedAuthReqEndpoint
  *   The URI of the pushed authorization request endpoint. This property corresponds to the
  *   `pushed_authorization_request_endpoint` metadata defined in \"[5. Authorization Server
  *   Metadata](https://tools.ietf.org/html/draft-lodderstedt-oauth-par#section-5)\" of OAuth 2.0
  *   Pushed Authorization Requests.
  * @param pushedAuthReqDuration
  *   The duration of pushed authorization requests in seconds. [OAuth 2.0 Pushed Authorization
  *   Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par) defines an endpoint (called
  *   \"pushed authorization request endpoint\") which client applications can register
  *   authorization requests into and get corresponding URIs (called \"request URIs\") from. The
  *   issued URIs represent the registered authorization requests. The client applications can use
  *   the URIs as the value of the `request_uri` request parameter in an authorization request. The
  *   property represents the duration of registered authorization requests and is used as the value
  *   of the `expires_in` parameter in responses from the pushed authorization request endpoint.
  * @param parRequired
  *   The flag to indicate whether this service requires that clients use the pushed authorization
  *   request endpoint. This property corresponds to the `require_pushed_authorization_requests`
  *   server metadata defined in [OAuth 2.0 Pushed Authorization
  *   Requests](https://tools.ietf.org/html/draft-lodderstedt-oauth-par).
  * @param requestObjectRequired
  *   The flag to indicate whether this service requires that authorization requests always utilize
  *   a request object by using either request or `request_uri` request parameter. If this flag is
  *   set to `true` and the value of `traditionalRequestObjectProcessingApplied` is `false`, the
  *   value of `require_signed_request_object` server metadata of this service is reported as `true`
  *   in the discovery document. The metadata is defined in JAR (JWT Secured Authorization Request).
  *   That `require_signed_request_object` is `true` means that authorization requests which don't
  *   conform to the JAR specification are rejected.
  * @param traditionalRequestObjectProcessingApplied
  *   The flag to indicate whether a request object is processed based on rules defined in [OpenID
  *   Connect Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) or JAR (JWT Secured
  *   Authorization Request). Differences between rules in OpenID Connect Core 1.0 and ones in JAR
  *   are as follows. - JAR requires that a request object be always -signed. - JAR does not allow
  *   request parameters outside a request object to be referred to. - OIDC Core 1.0 requires that
  *   response_type request parameter exist outside a request object even if the request object
  *   includes the request parameter. - OIDC Core 1.0 requires that scope request parameter exist
  *   outside a request object if the authorization request is an - OIDC request even if the request
  *   object includes the request parameter. If this flag is set to `false` and the value of
  *   `requestObjectRequired` is `true`, the value of `require_signed_request_object` server
  *   metadata of this service is reported as `true` in the discovery document. The metadata is
  *   defined in JAR (JWT Secured Authorization Request). That `require_signed_request_object` is
  *   `true` means that authorization requests which don't conform to the JAR specification are
  *   rejected.
  * @param mutualTlsValidatePkiCertChain
  *   The flag to indicate whether this service validates certificate chains during PKI-based client
  *   mutual TLS authentication.
  * @param trustedRootCertificates
  *   The list of root certificates trusted by this service for PKI-based client mutual TLS
  *   authentication.
  * @param mtlsEndpointAliases
  *   The MTLS endpoint aliases. This property corresponds to the mtls_endpoint_aliases metadata
  *   defined in \"5. Metadata for Mutual TLS Endpoint Aliases\" of [OAuth 2.0 Mutual TLS Client
  *   Authentication and Certificate-Bound Access
  *   Tokens](https://datatracker.ietf.org/doc/rfc8705/). The aliases will be embedded in the
  *   response from the discovery endpoint like the following. ```json {   ......,   \"mtls_endpoint_aliases\": {     \"token_endpoint\":         \"https://mtls.example.com/token\",     \"revocation_endpoint\":    \"https://mtls.example.com/revo\",     \"introspection_endpoint\": \"https://mtls.example.com/introspect\"   } } ```
  * @param accessTokenType
  *   The access token type. This value is used as the value of `token_type` property in access
  *   token responses. If this service complies with [RFC
  *   6750](https://tools.ietf.org/html/rfc6750), the value of this property should be `Bearer`. See
  *   [RFC 6749 (OAuth 2.0), 7.1. Access Token
  *   Types](https://tools.ietf.org/html/rfc6749#section-7.1) for details.
  * @param tlsClientCertificateBoundAccessTokens
  *   The flag to indicate whether this service supports issuing TLS client certificate bound access
  *   tokens.
  * @param accessTokenDuration
  *   The duration of access tokens in seconds. This value is used as the value of `expires_in`
  *   property in access token responses. `expires_in` is defined [RFC 6749, 5.1. Successful
  *   Response](https://tools.ietf.org/html/rfc6749#section-5.1).
  * @param singleAccessTokenPerSubject
  *   The flag to indicate whether the number of access tokens per subject (and per client) is at
  *   most one or can be more. If `true`, an attempt to issue a new access token invalidates
  *   existing access tokens that are associated with the same subject and the same client. Note
  *   that, however, attempts by [Client Credentials
  *   Flow](https://tools.ietf.org/html/rfc6749#section-4.4) do not invalidate existing access
  *   tokens because access tokens issued by Client Credentials Flow are not associated with any
  *   end-user's subject. Also note that an attempt by [Refresh Token
  *   Flow](https://tools.ietf.org/html/rfc6749#section-6) invalidates the coupled access token only
  *   and this invalidation is always performed regardless of whether the value of this setting item
  *   is `true` or `false`.
  * @param accessTokenSignAlg
  * @param accessTokenSignatureKeyId
  *   The key ID to identify a JWK used for signing access tokens. A JWK Set can be registered as a
  *   property of a service. A JWK Set can contain 0 or more JWKs. Authlete Server has to pick up
  *   one JWK for signing from the JWK Set when it generates a JWT-based access token. Authlete
  *   Server searches the registered JWK Set for a JWK which satisfies conditions for access token
  *   signature. If the number of JWK candidates which satisfy the conditions is 1, there is no
  *   problem. On the other hand, if there exist multiple candidates, a Key ID is needed to be
  *   specified so that Authlete Server can pick up one JWK from among the JWK candidates.
  * @param refreshTokenDuration
  *   The duration of refresh tokens in seconds. The related specifications have no requirements on
  *   refresh token duration, but Authlete sets expiration for refresh tokens.
  * @param refreshTokenDurationKept
  *   The flag to indicate whether the remaining duration of the used refresh token is taken over to
  *   the newly issued refresh token.
  * @param refreshTokenDurationReset
  *   The flag which indicates whether duration of refresh tokens are reset when they are used even
  *   if the `refreshTokenKept` property of this service set to is `true` (= even if \"Refresh Token
  *   Continuous Use\" is \"Kept\"). This flag has no effect when the `refreshTokenKept` property is
  *   set to `false`. In other words, if this service issues a new refresh token on every refresh
  *   token request, the refresh token will have fresh duration (unless `refreshTokenDurationKept`
  *   is set to `true`) and this `refreshTokenDurationReset` property is not referenced.
  * @param refreshTokenKept
  *   The flag to indicate whether a refresh token remains unchanged or gets renewed after its use.
  *   If `true`, a refresh token used to get a new access token remains valid after its use.
  *   Otherwise, if `false`, a refresh token is invalidated after its use and a new refresh token is
  *   issued. See [RFC 6749 6. Refreshing an Access
  *   Token](https://tools.ietf.org/html/rfc6749#section-6), as to how to get a new access token
  *   using a refresh token.
  * @param supportedScopes
  *   Scopes supported by the service. Authlete strongly recommends that the service register at
  *   least the following scopes. | Name | Description | | --- | --- | | openid | A permission to
  *   get an ID token of an end-user. The `openid` scope appears in [OpenID Connect Core 1.0,
  *   3.1.2.1. Authentication Request,
  *   scope](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest). Without this scope,
  *   Authlete does not allow `response_type` request parameter to have values other than code and
  *   token. | | profile | A permission to get information about `name`, `family_name`,
  *   `given_name`, `middle_name`, `nickname`, `preferred_username`, `profile`, `picture`,
  *   `website`, `gender`, `birthdate`, `zoneinfo`, `locale` and `updated_at` from the user info
  *   endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope
  *   Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. | |
  *   email | A permission to get information about `email` and `email_verified` from the user info
  *   endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope
  *   Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. | |
  *   address | A permission to get information about address from the user info endpoint. See
  *   [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope
  *   Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) and [5.1.1. Address
  *   Claim](https://openid.net/specs/openid-connect-core-1_0.html#AddressClaim) for details. | |
  *   phone | A permission to get information about `phone_number` and `phone_number_verified` from
  *   the user info endpoint. See [OpenID Connect Core 1.0, 5.4. Requesting Claims using Scope
  *   Values](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims) for details. | |
  *   offline_access | A permission to get information from the user info endpoint even when the
  *   end-user is not present. See [OpenID Connect Core 1.0, 11. Offline
  *   Access](https://openid.net/specs/openid-connect-core-1_0.html#OfflineAccess) for details. |
  *   The value of this property is used as `scopes_supported` property in the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param scopeRequired
  *   The flag to indicate whether requests that request no scope are rejected or not. When a
  *   request has no explicit `scope` parameter and the service's pre-defined default scope set is
  *   empty, the authorization server regards the request requests no scope. When this flag is set
  *   to `true`, requests that request no scope are rejected. The requirement below excerpted from
  *   [RFC 6749 Section 3.3](https://tools.ietf.org/html/rfc6749#section-3.3) does not explicitly
  *   mention the case where the default scope set is empty. > If the client omits the scope
  *   parameter when requesting authorization, the authorization server MUST either process the
  *   request using a pre-defined default value or fail the request indicating an invalid scope.
  *   However, if you interpret *\"the default scope set exists but is empty\"* as *\"the default
  *   scope set does not exist\"* and want to strictly conform to the requirement above, this flag
  *   has to be `true`.
  * @param idTokenDuration
  *   'The duration of [ID token](https://openid.net/specs/openid-connect-core-1_0.html#IDToken)s in
  *   seconds. This value is used to calculate the value of `exp` claim in an ID token.'
  * @param allowableClockSkew
  *   The allowable clock skew between the server and clients in seconds. The clock skew is taken
  *   into consideration when time-related claims in a JWT (e.g. `exp`, `iat`, `nbf`) are verified.
  * @param supportedClaimTypes
  *   Claim types supported by the service. Valid values are listed in Claim Type. Note that
  *   Authlete currently doesn't provide any API to help implementations for `AGGREGATED` and
  *   `DISTRIBUTED`. The value of this property is used as `claim_types_supported` property in the
  *   [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param supportedClaimLocales
  *   Claim locales that the service supports. Each element is a language tag defined in [RFC
  *   5646](https://tools.ietf.org/html/rfc5646). For example, `en-US` and `ja-JP`. See [OpenID
  *   Connect Core 1.0, 5.2. Languages and
  *   Scripts](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsLanguagesAndScripts) for
  *   details. The value of this property is used as `claims_locales_supported` property in the
  *   [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param supportedClaims
  *   Claim names that the service supports. The standard claim names listed in [OpenID Connect Core
  *   1.0, 5.1. Standard
  *   Claim](https://openid.net/specs/openid-connect-core-1_0.html#StandardClaims) should be
  *   supported. The following is the list of standard claims. - `sub` - `name` - `given_name` -
  *   `family_name` - `middle_name` - `nickname` - `preferred_username` - `profile` - `picture` -
  *   `website` - `email` - `email_verified` - `gender` - `birthdate` - `zoneinfo` - `locale` -
  *   `phone_number` - `phone_number_verified` - `address` - `updated_at` The value of this property
  *   is used as `claims_supported` property in the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata). The
  *   service may support its original claim names. See [OpenID Connect Core 1.0, 5.1.2. Additional
  *   Claims](https://openid.net/specs/openid-connect-core-1_0.html#AdditionalClaims).
  * @param claimShortcutRestrictive
  *   The flag indicating whether claims specified by shortcut scopes (e.g. `profile`) are included
  *   in the issued ID token only when no access token is issued. To strictly conform to the
  *   description below excerpted from [OpenID Connect Core 1.0 Section
  *   5.4](https://openid.net/specs/openid-connect-core-1_0.html#ScopeClaims), this flag has to be
  *   `true`. > The Claims requested by the profile, email, address, and phone scope values are
  *   returned from the UserInfo Endpoint, as described in Section 5.3.2, when a response_type value
  *   is used that results in an Access Token being issued. However, when no Access Token is issued
  *   (which is the case for the response_type value id_token), the resulting Claims are returned in
  *   the ID Token.
  * @param jwksUri
  *   The URL of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document. For
  *   example, `http://example.com/auth/jwks`. Client applications accesses this URL (1) to get the
  *   public key of the service to validate the signature of an ID token issued by the service and
  *   (2) to get the public key of the service to encrypt an request object of the client
  *   application. See [OpenID Connect Core 1.0, 10. Signatures and
  *   Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for details. The
  *   value of this property is used as `jwks_uri` property in the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param directJwksEndpointEnabled
  *   'The flag to indicate whether the direct jwks endpoint is enabled or not. The path of the
  *   endpoint is `/api/service/jwks/get/direct/service-api-key`. '
  * @param jwks
  *   The content of the service's [JSON Web Key Set](https://tools.ietf.org/html/rfc7517) document.
  *   If this property is not `null` in a `/service/create` request or a `/service/update` request,
  *   Authlete hosts the content in the database. This property must not be `null` and must contain
  *   pairs of public/private keys if the service wants to support asymmetric signatures for ID
  *   tokens and asymmetric encryption for request objects. See [OpenID Connect Core 1.0, 10.
  *   Signatures and Encryption](https://openid.net/specs/openid-connect-core-1_0.html#SigEnc) for
  *   details.
  * @param idTokenSignatureKeyId
  *   The key ID to identify a JWK used for ID token signature using an asymmetric key. A JWK Set
  *   can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs (See [RFC
  *   7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has to pick
  *   up one JWK for signature from the JWK Set when it generates an ID token and signature using an
  *   asymmetric key is required. Authlete Server searches the registered JWK Set for a JWK which
  *   satisfies conditions for ID token signature. If the number of JWK candidates which satisfy the
  *   conditions is 1, there is no problem. On the other hand, if there exist multiple candidates, a
  *   [Key ID](https://tools.ietf.org/html/rfc7517#section-4.5) is needed to be specified so that
  *   Authlete Server can pick up one JWK from among the JWK candidates. This
  *   `idTokenSignatureKeyId` property exists for the purpose described above. For key rotation
  *   (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing
  *   Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)), this mechanism is
  *   needed.
  * @param userInfoSignatureKeyId
  *   The key ID to identify a JWK used for user info signature using an asymmetric key. A JWK Set
  *   can be registered as a property of a Service. A JWK Set can contain 0 or more JWKs (See [RFC
  *   7517](https://tools.ietf.org/html/rfc7517) for details about JWK). Authlete Server has to pick
  *   up one JWK for signature from the JWK Set when it is required to sign user info (which is
  *   returned from [userinfo
  *   endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo)) using an asymmetric
  *   key. Authlete Server searches the registered JWK Set for a JWK which satisfies conditions for
  *   user info signature. If the number of JWK candidates which satisfy the conditions is 1, there
  *   is no problem. On the other hand, if there exist multiple candidates, a [Key
  *   ID](https://tools.ietf.org/html/rfc7517#section-4.5) is needed to be specified so that
  *   Authlete Server can pick up one JWK from among the JWK candidates. This
  *   `userInfoSignatureKeyId` property exists for the purpose described above. For key rotation
  *   (OpenID Connect Core 1.0, [10.1.1. Rotation of Asymmetric Signing
  *   Keys](http://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys)), this mechanism is
  *   needed.
  * @param authorizationSignatureKeyId
  *   The key ID to identify a JWK used for signing authorization responses using an asymmetric key.
  *   [Financial-grade API: JWT Secured Authorization Response Mode for OAuth 2.0
  *   (JARM)](https://openid.net/specs/openid-financial-api-jarm.html) defines new values for the
  *   `response_mode` request parameter. They are `query.jwt`, `fragment.jwt`, `form_post.jwt` and
  *   `jwt`. If one of them is specified as the response mode, response parameters from the
  *   authorization endpoint will be packed into a JWT. This property is used to compute the value
  *   of the `exp` claim of the JWT. Authlete Server searches the JWK Set for a JWK which satisfies
  *   conditions for authorization response signature. If the number of JWK candidates which satisfy
  *   the conditions is 1, there is no problem. On the other hand, if there exist multiple
  *   candidates, a Key ID is needed to be specified so that Authlete Server can pick up one JWK
  *   from among the JWK candidates. This property exists to specify the key ID.
  * @param userInfoEndpoint
  *   The [user info endpoint](http://openid.net/specs/openid-connect-core-1_0.html#UserInfo) of the
  *   service. A URL that starts with `https://`. For example, `https://example.com/auth/userinfo`.
  *   The value of this property is used as `userinfo_endpoint` property in the [OpenID Provider
  *   Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param directUserInfoEndpointEnabled
  *   The flag to indicate whether the direct userinfo endpoint is enabled or not. The path of the
  *   endpoint is `/api/auth/userinfo/direct/service-api-key`.
  * @param dynamicRegistrationSupported
  *   The boolean flag which indicates whether the [OAuth 2.0 Dynamic Client Registration
  *   Protocol](https://tools.ietf.org/html/rfc7591) is supported.
  * @param registrationEndpoint
  *   The [registration
  *   endpoint](http://openid.net/specs/openid-connect-registration-1_0.html#ClientRegistration) of
  *   the service. A URL that starts with `https://`. For example,
  *   `https://example.com/auth/registration`. The value of this property is used as
  *   `registration_endpoint` property in the [OpenID Provider
  *   Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param registrationManagementEndpoint
  *   The URI of the registration management endpoint. If dynamic client registration is supported,
  *   and this is set, this URI will be used as the basis of the client's management endpoint by
  *   appending `/clientid}/` to it as a path element. If this is unset, the value of
  *   `registrationEndpoint` will be used as the URI base instead.
  * @param policyUri
  *   The URL of the \"Policy\" of the service. The value of this property is used as
  *   `op_policy_uri` property in the [OpenID Provider
  *   Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param tosUri
  *   The URL of the \"Terms Of Service\" of the service. The value of this property is used as
  *   `op_tos_uri` property in the [OpenID Provider
  *   Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param serviceDocumentation
  *   The URL of a page where documents for developers can be found. The value of this property is
  *   used as `service_documentation` property in the [OpenID Provider
  *   Metadata](http://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param backchannelAuthenticationEndpoint
  *   The URI of backchannel authentication endpoint, which is defined in the specification of [CIBA
  *   (Client Initiated Backchannel
  *   Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
  * @param supportedBackchannelTokenDeliveryModes
  *   The supported backchannel token delivery modes. This property corresponds to the
  *   `backchannel_token_delivery_modes_supported` metadata. Backchannel token delivery modes are
  *   defined in the specification of [CIBA (Client Initiated Backchannel
  *   Authentication)](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html).
  * @param backchannelAuthReqIdDuration
  *   The duration of backchannel authentication request IDs issued from the backchannel
  *   authentication endpoint in seconds. This is used as the value of the `expires_in` property in
  *   responses from the backchannel authentication endpoint.
  * @param backchannelPollingInterval
  *   The minimum interval between polling requests to the token endpoint from client applications
  *   in seconds. This is used as the value of the `interval` property in responses from the
  *   backchannel authentication endpoint.
  * @param backchannelUserCodeParameterSupported
  *   The boolean flag which indicates whether the `user_code` request parameter is supported at the
  *   backchannel authentication endpoint. This property corresponds to the
  *   `backchannel_user_code_parameter_supported` metadata.
  * @param backchannelBindingMessageRequiredInFapi
  *   The flag to indicate whether the `binding_message` request parameter is always required
  *   whenever a backchannel authentication request is judged as a request for Financial-grade API.
  *   The FAPI-CIBA profile requires that the authorization server _\"shall ensure unique
  *   authorization context exists in the authorization request or require a `binding_message` in
  *   the authorization request\"_ (FAPI-CIBA, 5.2.2, 2). The simplest way to fulfill this
  *   requirement is to set this property to `true`. If this property is set to `false`, the
  *   `binding_message` request parameter remains optional even in FAPI context, but in exchange,
  *   your authorization server must implement a custom mechanism that ensures each backchannel
  *   authentication request has unique context.
  * @param deviceAuthorizationEndpoint
  *   The URI of the device authorization endpoint. Device authorization endpoint is defined in the
  *   specification of OAuth 2.0 Device Authorization Grant.
  * @param deviceVerificationUri
  *   The verification URI for the device flow. This URI is used as the value of the
  *   `verification_uri` parameter in responses from the device authorization endpoint.
  * @param deviceVerificationUriComplete
  *   The verification URI for the device flow with a placeholder for a user code. This URI is used
  *   to build the value of the `verification_uri_complete` parameter in responses from the device
  *   authorization endpoint. It is expected that the URI contains a fixed string `USER_CODE`
  *   somewhere as a placeholder for a user code. For example, like the following.
  *   `https://example.com/device?user\\_code=USER\\_CODE` The fixed string is replaced with an
  *   actual user code when Authlete builds a verification URI with a user code for the
  *   `verification_uri_complete` parameter. If this URI is not set, the `verification_uri_complete`
  *   parameter won't appear in device authorization responses.
  * @param deviceFlowCodeDuration
  *   The duration of device verification codes and end-user verification codes issued from the
  *   device authorization endpoint in seconds. This is used as the value of the `expires_in`
  *   property in responses from the device authorization endpoint.
  * @param deviceFlowPollingInterval
  *   The minimum interval between polling requests to the token endpoint from client applications
  *   in seconds in device flow. This is used as the value of the `interval` property in responses
  *   from the device authorization endpoint.
  * @param userCodeCharset
  * @param userCodeLength
  *   The length of end-user verification codes (`user_code`) for Device Flow.
  * @param supportedTrustFrameworks
  *   Trust frameworks supported by this service. This corresponds to the
  *   `trust_frameworks_supported`
  *   [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
  * @param supportedEvidence
  *   Evidence supported by this service. This corresponds to the `evidence_supported`
  *   [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
  * @param supportedIdentityDocuments
  *   Identity documents supported by this service. This corresponds to the `id_documents_supported`
  *   [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
  * @param supportedVerificationMethods
  *   Verification methods supported by this service. This corresponds to the
  *   `id_documents_verification_methods_supported`
  *   [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
  * @param supportedVerifiedClaims
  *   Verified claims supported by this service. This corresponds to the
  *   `claims_in_verified_claims_supported`
  *   [metadata](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html#rfc.section.7).
  * @param verifiedClaimsValidationSchemaSet
  * @param attributes
  *   The attributes of this service.
  * @param nbfOptional
  *   The flag indicating whether the nbf claim in the request object is optional even when the
  *   authorization request is regarded as a FAPI-Part2 request. The final version of
  *   Financial-grade API was approved in January, 2021. The Part 2 of the final version has new
  *   requirements on lifetime of request objects. They require that request objects contain an
  *   `nbf` claim and the lifetime computed by `exp` - `nbf` be no longer than 60 minutes.
  *   Therefore, when an authorization request is regarded as a FAPI-Part2 request, the request
  *   object used in the authorization request must contain an nbf claim. Otherwise, the
  *   authorization server rejects the authorization request. When this flag is `true`, the `nbf`
  *   claim is treated as an optional claim even when the authorization request is regarded as a
  *   FAPI-Part2 request. That is, the authorization server does not perform the validation on
  *   lifetime of the request object. Skipping the validation is a violation of the FAPI
  *   specification. The reason why this flag has been prepared nevertheless is that the new
  *   requirements (which do not exist in the Implementer's Draft 2 released in October, 2018) have
  *   big impacts on deployed implementations of client applications and Authlete thinks there
  *   should be a mechanism whereby to make the migration from ID2 to Final smooth without breaking
  *   live systems.
  * @param issSuppressed
  *   The flag indicating whether generation of the iss response parameter is suppressed. \"OAuth
  *   2.0 Authorization Server Issuer Identifier in Authorization Response\" has defined a new
  *   authorization response parameter, `iss`, as a countermeasure for a certain type of mix-up
  *   attacks. The specification requires that the `iss` response parameter always be included in
  *   authorization responses unless JARM (JWT Secured Authorization Response Mode) is used. When
  *   this flag is `true`, the authorization server does not include the `iss` response parameter in
  *   authorization responses. By turning this flag on and off, developers of client applications
  *   can experiment the mix-up attack and the effect of the `iss` response parameter. Note that
  *   this flag should not be `true` in production environment unless there are special reasons for
  *   it.
  * @param supportedCustomClientMetadata
  *   custom client metadata supported by this service. Standard specifications define client
  *   metadata as necessary. The following are such examples. * [OpenID Connect Dynamic Client
  *   Registration 1.0](https://openid.net/specs/openid-connect-registration-1_0.html) * [RFC 7591
  *   OAuth 2.0 Dynamic Client Registration Protocol](https://www.rfc-editor.org/rfc/rfc7591.html) *
  *   [RFC 8705 OAuth 2.0 Mutual-TLS Client Authentication and Certificate-Bound Access
  *   Tokens](https://www.rfc-editor.org/rfc/rfc8705.html) * [OpenID Connect Client-Initiated
  *   Backchannel Authentication Flow - Core
  *   1.0](https://openid.net/specs/openid-client-initiated-backchannel-authentication-core-1_0.html)
  *   * [The OAuth 2.0 Authorization Framework: JWT Secured Authorization Request
  *   (JAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-jwsreq/) * [Financial-grade API: JWT
  *   Secured Authorization Response Mode for OAuth 2.0
  *   (JARM)](https://openid.net/specs/openid-financial-api-jarm.html) * [OAuth 2.0 Pushed
  *   Authorization Requests (PAR)](https://datatracker.ietf.org/doc/rfc9126/) * [OAuth 2.0 Rich
  *   Authorization Requests (RAR)](https://datatracker.ietf.org/doc/draft-ietf-oauth-rar/) Standard
  *   client metadata included in Client Registration Request and Client Update Request (cf. [OIDC
  *   DynReg](https://openid.net/specs/openid-connect-registration-1_0.html), [RFC
  *   7591](https://www.rfc-editor.org/rfc/rfc7591.html) and [RFC
  *   7592](https://www.rfc-editor.org/rfc/rfc7592.html)) are, if supported by Authlete, stored into
  *   Authlete database. On the other hand, unrecognized client metadata are discarded. By listing
  *   up custom client metadata in advance by using this property (`supportedCustomClientMetadata`),
  *   Authlete can recognize them and stores their values into the database. The stored custom
  *   client metadata values can be referenced by `customMetadata`.
  * @param tokenExpirationLinked
  *   The flag indicating whether the expiration date of an access token never exceeds that of the
  *   corresponding refresh token. When a new access token is issued by a refresh token request (= a
  *   token request with `grant_type=refresh_token`), the expiration date of the access token may
  *   exceed the expiration date of the corresponding refresh token. This behavior itself is not
  *   wrong and may happen when `refreshTokenKept` is `true` and/or when `refreshTokenDurationKept`
  *   is `true`. When this flag is `true`, the expiration date of an access token never exceeds that
  *   of the corresponding refresh token regardless of the calculated duration based on other
  *   settings such as `accessTokenDuration`, `accessTokenDuration` in `extension` and
  *   `access_token.duration` scope attribute. It is technically possible to set a value which is
  *   bigger than the duration of refresh tokens as the duration of access tokens although it is
  *   strange. In the case, the duration of an access token becomes longer than the duration of the
  *   refresh token which is issued together with the access token. Even if the duration values are
  *   configured so, if this flag is `true`, the expiration date of the access token does not exceed
  *   that of the refresh token. That is, the duration of the access token will be shortened, and as
  *   a result, the access token and the refresh token will have the same expiration date.
  * @param frontChannelRequestObjectEncryptionRequired
  *   The flag indicating whether encryption of request object is required when the request object
  *   is passed through the front channel. This flag does not affect the processing of request
  *   objects at the Pushed Authorization Request Endpoint, which is defined in [OAuth 2.0 Pushed
  *   Authorization Requests](https://datatracker.ietf.org/doc/rfc9126/). Unecrypted request objects
  *   are accepted at the endpoint even if this flag is `true`. This flag does not indicate whether
  *   a request object is always required. There is a different flag, `requestObjectRequired`, for
  *   the purpose. See the description of `requestObjectRequired` for details. Even if this flag is
  *   `false`, encryption of request object is required if the
  *   `frontChannelRequestObjectEncryptionRequired` flag of the client is `true`.
  * @param requestObjectEncryptionAlgMatchRequired
  *   The flag indicating whether the JWE alg of encrypted request object must match the
  *   `request_object_encryption_alg` client metadata of the client that has sent the request
  *   object. The request_object_encryption_alg client metadata itself is defined in [OpenID Connect
  *   Dynamic Client Registration
  *   1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows. >
  *   request_object_encryption_alg > > OPTIONAL. JWE [JWE] alg algorithm [JWA] the RP is declaring
  *   that it may use for encrypting Request Objects sent to the OP. This parameter SHOULD be
  *   included when symmetric encryption will be used, since this signals to the OP that a
  *   client_secret value needs to be returned from which the symmetric key will be derived, that
  *   might not otherwise be returned. The RP MAY still use other supported encryption algorithms or
  *   send unencrypted Request Objects, even when this parameter is present. If both signing and
  *   encryption are requested, the Request Object will be signed then encrypted, with the result
  *   being a Nested JWT, as defined in [JWT]. The default, if omitted, is that the RP is not
  *   declaring whether it might encrypt any Request Objects. The point here is \"The RP MAY still
  *   use other supported encryption algorithms or send unencrypted Request Objects, even when this
  *   parameter is present.\" The Client's property that represents the client metadata is
  *   `requestEncryptionAlg`. See the description of `requestEncryptionAlg` for details. Even if
  *   this flag is `false`, the match is required if the `requestObjectEncryptionAlgMatchRequired`
  *   flag of the client is `true`.
  * @param requestObjectEncryptionEncMatchRequired
  *   The flag indicating whether the JWE `enc` of encrypted request object must match the
  *   `request_object_encryption_enc` client metadata of the client that has sent the request
  *   object. The `request_object_encryption_enc` client metadata itself is defined in [OpenID
  *   Connect Dynamic Client Registration
  *   1.0](https://openid.net/specs/openid-connect-registration-1_0.html) as follows. >
  *   request_object_encryption_enc > > OPTIONAL. JWE enc algorithm [JWA] the RP is declaring that
  *   it may use for encrypting Request Objects sent to the OP. If request_object_encryption_alg is
  *   specified, the default for this value is A128CBC-HS256. When request_object_encryption_enc is
  *   included, request_object_encryption_alg MUST also be provided. The Client's property that
  *   represents the client metadata is `requestEncryptionEnc`. See the description of
  *   `requestEncryptionEnc` for details. Even if this flag is false, the match is required if the
  *   `requestObjectEncryptionEncMatchRequired` flag is `true`.
  * @param hsmEnabled
  *   The flag indicating whether HSM (Hardware Security Module) support is enabled for this
  *   service. When this flag is `false`, keys managed in HSMs are not used even if they exist. In
  *   addition, `/api/hsk/_*` APIs reject all requests. Even if this flag is `true`, HSM-related
  *   features do not work if the configuration of the Authlete server you are using does not
  *   support HSM.
  * @param hsks
  *   The information about keys managed on HSMs (Hardware Security Modules). This `hsks` property
  *   is output only, meaning that `hsks` in requests to `/api/service/create` API and
  *   `/api/service/update` API do not have any effect. The contents of this property is controlled
  *   only by `/api/hsk/_*` APIs.
  * @param grantManagementEndpoint
  *   The URL of the grant management endpoint.
  * @param grantManagementActionRequired
  *   The flag indicating whether every authorization request (and any request serving as an
  *   authorization request such as CIBA backchannel authentication request and device authorization
  *   request) must include the `grant_management_action` request parameter. This property
  *   corresponds to the `grant_management_action_required` server metadata defined in [Grant
  *   Management for OAuth 2.0](https://openid.net/specs/fapi-grant-management.html). Note that
  *   setting true to this property will result in blocking all public clients because the
  *   specification requires that grant management be usable only by confidential clients for
  *   security reasons.
  * @param unauthorizedOnClientConfigSupported
  *   The flag indicating whether Authlete's `/api/client/registration` API uses `UNAUTHORIZED` as a
  *   value of the `action` response parameter when appropriate. The `UNAUTHORIZED` enum value was
  *   initially not defined as a possible value of the `action` parameter in an
  *   `/api/client/registration` API response. This means that implementations of client
  *   `configuration` endpoint were not able to conform to [RFC
  *   7592](https://www.rfc-editor.org/rfc/rfc7592.html) strictly. For backward compatibility (to
  *   avoid breaking running systems), Authlete's `/api/client/registration` API does not return the
  *   `UNAUTHORIZED` enum value if this flag is not turned on. The steps an existing implementation
  *   of client configuration endpoint has to do in order to conform to the requirement related to
  *   \"401 Unauthorized\" are as follows. 1. Update the Authlete library (e.g.
  *   authlete-java-common) your system is using. 2. Update your implementation of client
  *   configuration endpoint so that it can handle the `UNAUTHORIZED` action. 3. Turn on this
  *   `unauthorizedOnClientConfigSupported` flag.
  * @param dcrScopeUsedAsRequestable
  *   The flag indicating whether the `scope` request parameter in dynamic client registration and
  *   update requests (RFC 7591 and RFC 7592) is used as scopes that the client can request.
  *   Limiting the range of scopes that a client can request is achieved by listing scopes in the
  *   `client.extension.requestableScopes` property and setting the
  *   `client.extension.requestableScopesEnabled` property to `true`. This feature is called
  *   \"requestable scopes\". This property affects behaviors of `/api/client/registration` and
  *   other family APIs.
  * @param endSessionEndpoint
  *   The endpoint for clients ending the sessions. A URL that starts with `https://` and has no
  *   fragment component. For example, `https://example.com/auth/endSession`. The value of this
  *   property is used as `end_session_endpoint` property in the [OpenID Provider
  *   Metadata](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderMetadata).
  * @param loopbackRedirectionUriVariable
  *   The flag indicating whether the port number component of redirection URIs can be variable when
  *   the host component indicates loopback. When this flag is `true`, if the host component of a
  *   redirection URI specified in an authorization request indicates loopback (to be precise, when
  *   the host component is localhost, `127.0.0.1` or `::1`), the port number component is ignored
  *   when the specified redirection URI is compared to pre-registered ones. This behavior is
  *   described in [7.3. Loopback Interface Redirection](
  *   https://www.rfc-editor.org/rfc/rfc8252.html#section-7.3) of [RFC 8252 OAuth
  *   2.0](https://www.rfc-editor.org/rfc/rfc8252.html) for Native Apps. [3.1.2.3. Dynamic
  *   Configuration](https://www.rfc-editor.org/rfc/rfc6749.html#section-3.1.2.3) of [RFC
  *   6749](https://www.rfc-editor.org/rfc/rfc6749.html) states _\"If the client registration
  *   included the full redirection URI, the authorization server MUST compare the two URIs using
  *   simple string comparison as defined in [RFC3986] Section 6.2.1.\"_ Also, the description of
  *   `redirect_uri` in [3.1.2.1. Authentication
  *   Request](https://openid.net/specs/openid-connect-core-1_0.html#AuthRequest) of [OpenID Connect
  *   Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) states _\"This URI MUST
  *   exactly match one of the Redirection URI values for the Client pre-registered at the OpenID
  *   Provider, with the matching performed as described in Section 6.2.1 of [RFC3986] (**Simple
  *   String Comparison**).\"_ These \"Simple String Comparison\" requirements are preceded by this
  *   flag. That is, even when the conditions described in RFC 6749 and OpenID Connect Core 1.0 are
  *   satisfied, the port number component of loopback redirection URIs can be variable when this
  *   flag is `true`. [8.3. Loopback Redirect
  *   Considerations](https://www.rfc-editor.org/rfc/rfc8252.html#section-8.3) of [RFC
  *   8252](https://www.rfc-editor.org/rfc/rfc8252.html) states as follows. > While redirect URIs
  *   using localhost (i.e., `\"http://localhost:{port}/{path}\"`) function similarly to loopback IP
  *   redirects described in Section 7.3, the use of localhost is NOT RECOMMENDED. Specifying a
  *   redirect URI with the loopback IP literal rather than localhost avoids inadvertently listening
  *   on network interfaces other than the loopback interface. It is also less susceptible to
  *   client-side firewalls and misconfigured host name resolution on the user's device. However,
  *   Authlete allows the port number component to be variable in the case of `localhost`, too. It
  *   is left to client applications whether they use `localhost` or a literal loopback IP address
  *   (`127.0.0.1` for IPv4 or `::1` for IPv6). Section 7.3 and Section 8.3 of [RFC
  *   8252](https://www.rfc-editor.org/rfc/rfc8252.html) state that loopback redirection URIs use
  *   the `\"http\"` scheme, but Authlete allows the port number component to be variable in other
  *   cases (e.g. in the case of the `\"https\"` scheme), too.
  * @param requestObjectAudienceChecked
  *   The flag indicating whether Authlete checks whether the `aud` claim of request objects matches
  *   the issuer identifier of this service. [Section 6.1. Passing a Request Object by
  *   Value](https://openid.net/specs/openid-connect-core-1_0.html#JWTRequests) of [OpenID Connect
  *   Core 1.0](https://openid.net/specs/openid-connect-core-1_0.html) has the following statement.
  *   > The `aud` value SHOULD be or include the OP's Issuer Identifier URL. Likewise, [Section 4.
  *   Request Object](https://www.rfc-editor.org/rfc/rfc9101.html#section-4) of [RFC
  *   9101](https://www.rfc-editor.org/rfc/rfc9101.html) (The OAuth 2.0 Authorization Framework:
  *   JWT-Secured Authorization Request (JAR)) has the following statement. > The value of aud
  *   should be the value of the authorization server (AS) issuer, as defined in [RFC
  *   8414](https://www.rfc-editor.org/rfc/rfc8414.html). As excerpted above, validation on the
  *   `aud` claim of request objects is optional. However, if this flag is turned on, Authlete
  *   checks whether the `aud` claim of request objects matches the issuer identifier of this
  *   service and raises an error if they are different.
  * @param accessTokenForExternalAttachmentEmbedded
  *   The flag indicating whether Authlete generates access tokens for external attachments and
  *   embeds them in ID tokens and userinfo responses.
  * @param authorityHints
  *   Identifiers of entities that can issue entity statements for this service. This property
  *   corresponds to the `authority_hints` property that appears in a self-signed entity statement
  *   that is defined in OpenID Connect Federation 1.0.
  * @param federationEnabled
  *   flag indicating whether this service supports OpenID Connect Federation 1
  * @param federationJwks
  *   JWK Set document containing keys that are used to sign (1) self-signed entity statement of
  *   this service and (2) the response from `signed_jwks_uri`.
  * @param federationSignatureKeyId
  *   A key ID to identify a JWK used to sign the entity configuration and the signed JWK Set.
  * @param federationConfigurationDuration
  *   The duration of the entity configuration in seconds.
  * @param federationRegistrationEndpoint
  *   The URI of the federation registration endpoint. This property corresponds to the
  *   `federation_registration_endpoint` server metadata that is defined in OpenID Connect
  *   Federation 1.0.
  * @param organizationName
  *   The human-readable name representing the organization that operates this service. This
  *   property corresponds to the `organization_name` server metadata that is defined in OpenID
  *   Connect Federation 1.0.
  * @param predefinedTransformedClaims
  *   The transformed claims predefined by this service in JSON format. This property corresponds to
  *   the `transformed_claims_predefined` server metadata.
  * @param refreshTokenIdempotent
  *   flag indicating whether refresh token requests with the same refresh token can be made
  *   multiple times in quick succession and they can obtain the same renewed refresh token within
  *   the short period.
  * @param signedJwksUri
  *   The URI of the endpoint that returns this service's JWK Set document in the JWT format. This
  *   property corresponds to the `signed_jwks_uri` server metadata defined in OpenID Connect
  *   Federation 1.0.
  * @param supportedAttachments
  *   Supported attachment types. This property corresponds to the {@code attachments_supported}
  *   server metadata which was added by the third implementer's draft of OpenID Connect for
  *   Identity Assurance 1.0.
  * @param supportedDigestAlgorithms
  *   Supported algorithms used to compute digest values of external attachments. This property
  *   corresponds to the `digest_algorithms_supported` server metadata which was added by the third
  *   implementer's draft of OpenID Connect for Identity Assurance 1.0.
  * @param supportedDocuments
  *   Document types supported by this service. This property corresponds to the
  *   `documents_supported` server metadata.
  * @param supportedDocumentsMethods
  *   validation and verification processes supported by this service. This property corresponds to
  *   the `documents_methods_supported` server metadata. The third implementer's draft of [OpenID
  *   Connect for Identity Assurance
  *   1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html) renamed the
  *   `id_documents_verification_methods_supported` server metadata to
  *   `documents_methods_supported`.
  * @param supportedDocumentsValidationMethods
  *   Document validation methods supported by this service. This property corresponds to the
  *   `documents_validation_methods_supported` server metadata which was added by the third
  *   implementer's draft of <a href= [OpenID Connect for Identity Assurance
  *   1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
  * @param supportedDocumentsVerificationMethods
  *   Document verification methods supported by this service. This property corresponds to the
  *   `documents_verification_methods_supported` server metadata which was added by the third
  *   implementer's draft of [OpenID Connect for Identity Assurance
  *   1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
  * @param supportedElectronicRecords
  *   Electronic record types supported by this service. This property corresponds to the
  *   `electronic_records_supported` server metadata which was added by the third implementer's
  *   draft of [OpenID Connect for Identity Assurance
  *   1.0](https://openid.net/specs/openid-connect-4-identity-assurance-1_0.html)
  * @param supportedClientRegistrationTypes
  * @param tokenExchangeByIdentifiableClientsOnly
  *   The flag indicating whether to prohibit unidentifiable clients from making token exchange
  *   requests.
  * @param tokenExchangeByConfidentialClientsOnly
  *   The flag indicating whether to prohibit public clients from making token exchange requests.
  * @param tokenExchangeByPermittedClientsOnly
  *   The flag indicating whether to prohibit clients that have no explicit permission from making
  *   token exchange requests.
  * @param tokenExchangeEncryptedJwtRejected
  *   The flag indicating whether to reject token exchange requests which use encrypted JWTs as
  *   input tokens.
  * @param tokenExchangeUnsignedJwtRejected
  *   The flag indicating whether to reject token exchange requests which use unsigned JWTs as input
  *   tokens.
  * @param jwtGrantByIdentifiableClientsOnly
  *   The flag indicating whether to prohibit unidentifiable clients from using the grant type
  *   \"urn:ietf:params:oauth:grant-type:jwt-bearer\".
  * @param jwtGrantEncryptedJwtRejected
  *   The flag indicating whether to reject token requests that use an encrypted JWT as an
  *   authorization grant with the grant type \"urn:ietf:params:oauth:grant-type:jwt-bearer\".
  * @param jwtGrantUnsignedJwtRejected
  *   The flag indicating whether to reject token requests that use an unsigned JWT as an
  *   authorization grant with the grant type \"urn:ietf:params:oauth:grant-type:jwt-bearer\".
  * @param dcrDuplicateSoftwareIdBlocked
  *   The flag indicating whether to block DCR (Dynamic Client Registration) requests whose
  *   \"software_id\" has already been used previously.
  * @param trustAnchors
  *   The trust anchors that are referenced when this service resolves trust chains of relying
  *   parties. If this property is empty, client registration fails regardless of whether its type
  *   is `automatic` or `explicit`. It means that OpenID Connect Federation 1.0 does not work.
  * @param openidDroppedOnRefreshWithoutOfflineAccess
  *   The flag indicating whether the openid scope should be dropped from scopes list assigned to
  *   access token issued when a refresh token grant is used.
  * @param supportedDocumentsCheckMethods
  *   Supported document check methods. This property corresponds to the
  *   `documents_check_methods_supported` server metadata which was added by the fourth
  *   implementer's draft of OpenID Connect for Identity Assurance 1.0.
  * @param rsResponseSigned
  *   The flag indicating whether this service signs responses from the resource server.
  * @param resourceSignatureKeyId
  *   Get the key ID of a JWK containing the public key used by this client to sign requests to the
  *   resource server.
  * @param idTokenAudType
  *   The type of the `aud` claim in ID tokens.
  * @param idTokenReissuable
  *   The flag indicating whether to enable the feature of ID token reissuance in the refresh token
  *   flow.
  */
case class Service(
    number: Option[Int] = None,
    serviceOwnerNumber: Option[Int] = None,
    serviceName: Option[String] = None,
    issuer: Option[String] = None,
    description: Option[String] = None,
    apiKey: Option[Long] = None,
    apiSecret: Option[String] = None,
    clientsPerDeveloper: Option[Int] = None,
    clientIdAliasEnabled: Option[Boolean] = None,
    metadata: Option[Seq[Pair]] = None,
    createdAt: Option[Long] = None,
    modifiedAt: Option[Long] = None,
    authenticationCallbackEndpoint: Option[URI] = None,
    authenticationCallbackApiKey: Option[String] = None,
    authenticationCallbackApiSecret: Option[String] = None,
    supportedSnses: Option[Seq[Sns]] = None,
    snsCredentials: Option[Seq[SnsCredentials]] = None,
    supportedAcrs: Option[Seq[String]] = None,
    developerAuthenticationCallbackEndpoint: Option[URI] = None,
    developerAuthenticationCallbackApiKey: Option[String] = None,
    developerAuthenticationCallbackApiSecret: Option[String] = None,
    supportedDeveloperSnses: Option[Seq[Sns]] = None,
    developerSnsCredentials: Option[Seq[SnsCredentials]] = None,
    supportedGrantTypes: Option[Seq[GrantType]] = None,
    supportedResponseTypes: Option[Seq[ResponseType]] = None,
    supportedAuthorizationDetailsTypes: Option[Seq[String]] = None,
    supportedServiceProfiles: Option[Seq[ServiceProfile]] = None,
    errorDescriptionOmitted: Option[Boolean] = None,
    errorUriOmitted: Option[Boolean] = None,
    authorizationEndpoint: Option[URI] = None,
    directAuthorizationEndpointEnabled: Option[Boolean] = None,
    supportedUiLocales: Option[Seq[String]] = None,
    supportedDisplays: Option[Seq[Display]] = None,
    pkceRequired: Option[Boolean] = None,
    pkceS256Required: Option[Boolean] = None,
    authorizationResponseDuration: Option[Long] = None,
    tokenEndpoint: Option[URI] = None,
    directTokenEndpointEnabled: Option[Boolean] = None,
    supportedTokenAuthMethods: Option[Seq[ClientAuthMethod]] = None,
    missingClientIdAllowed: Option[Boolean] = None,
    revocationEndpoint: Option[URI] = None,
    directRevocationEndpointEnabled: Option[Boolean] = None,
    supportedRevocationAuthMethods: Option[Seq[ClientAuthMethod]] = None,
    introspectionEndpoint: Option[URI] = None,
    directIntrospectionEndpointEnabled: Option[Boolean] = None,
    supportedIntrospectionAuthMethods: Option[Seq[ClientAuthMethod]] = None,
    pushedAuthReqEndpoint: Option[URI] = None,
    pushedAuthReqDuration: Option[Long] = None,
    parRequired: Option[Boolean] = None,
    requestObjectRequired: Option[Boolean] = None,
    traditionalRequestObjectProcessingApplied: Option[Boolean] = None,
    mutualTlsValidatePkiCertChain: Option[Boolean] = None,
    trustedRootCertificates: Option[Seq[String]] = None,
    mtlsEndpointAliases: Option[Seq[NamedUri]] = None,
    accessTokenType: Option[String] = None,
    tlsClientCertificateBoundAccessTokens: Option[Boolean] = None,
    accessTokenDuration: Option[Long] = None,
    singleAccessTokenPerSubject: Option[Boolean] = None,
    accessTokenSignAlg: Option[JwsAlg] = None,
    accessTokenSignatureKeyId: Option[String] = None,
    refreshTokenDuration: Option[Long] = None,
    refreshTokenDurationKept: Option[Boolean] = None,
    refreshTokenDurationReset: Option[Boolean] = None,
    refreshTokenKept: Option[Boolean] = None,
    supportedScopes: Option[Seq[Scope]] = None,
    scopeRequired: Option[Boolean] = None,
    idTokenDuration: Option[Long] = None,
    allowableClockSkew: Option[Int] = None,
    supportedClaimTypes: Option[Seq[ClaimType]] = None,
    supportedClaimLocales: Option[Seq[String]] = None,
    supportedClaims: Option[Seq[String]] = None,
    claimShortcutRestrictive: Option[Boolean] = None,
    jwksUri: Option[URI] = None,
    directJwksEndpointEnabled: Option[Boolean] = None,
    jwks: Option[String] = None,
    idTokenSignatureKeyId: Option[String] = None,
    userInfoSignatureKeyId: Option[String] = None,
    authorizationSignatureKeyId: Option[String] = None,
    userInfoEndpoint: Option[URI] = None,
    directUserInfoEndpointEnabled: Option[Boolean] = None,
    dynamicRegistrationSupported: Option[Boolean] = None,
    registrationEndpoint: Option[URI] = None,
    registrationManagementEndpoint: Option[URI] = None,
    policyUri: Option[URI] = None,
    tosUri: Option[URI] = None,
    serviceDocumentation: Option[URI] = None,
    backchannelAuthenticationEndpoint: Option[URI] = None,
    supportedBackchannelTokenDeliveryModes: Option[Seq[DeliveryMode]] = None,
    backchannelAuthReqIdDuration: Option[Int] = None,
    backchannelPollingInterval: Option[Int] = None,
    backchannelUserCodeParameterSupported: Option[Boolean] = None,
    backchannelBindingMessageRequiredInFapi: Option[Boolean] = None,
    deviceAuthorizationEndpoint: Option[URI] = None,
    deviceVerificationUri: Option[URI] = None,
    deviceVerificationUriComplete: Option[URI] = None,
    deviceFlowCodeDuration: Option[Int] = None,
    deviceFlowPollingInterval: Option[Int] = None,
    userCodeCharset: Option[UserCodeCharset] = None,
    userCodeLength: Option[Int] = None,
    supportedTrustFrameworks: Option[Seq[String]] = None,
    supportedEvidence: Option[Seq[String]] = None,
    supportedIdentityDocuments: Option[Seq[String]] = None,
    supportedVerificationMethods: Option[Seq[String]] = None,
    supportedVerifiedClaims: Option[Seq[String]] = None,
    verifiedClaimsValidationSchemaSet: Option[VerifiedClaimsValidationSchema] = None,
    attributes: Option[Seq[Pair]] = None,
    nbfOptional: Option[Boolean] = None,
    issSuppressed: Option[Boolean] = None,
    supportedCustomClientMetadata: Option[Seq[String]] = None,
    tokenExpirationLinked: Option[Boolean] = None,
    frontChannelRequestObjectEncryptionRequired: Option[Boolean] = None,
    requestObjectEncryptionAlgMatchRequired: Option[Boolean] = None,
    requestObjectEncryptionEncMatchRequired: Option[Boolean] = None,
    hsmEnabled: Option[Boolean] = None,
    hsks: Option[Seq[Hsk]] = None,
    grantManagementEndpoint: Option[String] = None,
    grantManagementActionRequired: Option[Boolean] = None,
    unauthorizedOnClientConfigSupported: Option[Boolean] = None,
    dcrScopeUsedAsRequestable: Option[Boolean] = None,
    endSessionEndpoint: Option[URI] = None,
    loopbackRedirectionUriVariable: Option[Boolean] = None,
    requestObjectAudienceChecked: Option[Boolean] = None,
    accessTokenForExternalAttachmentEmbedded: Option[Boolean] = None,
    authorityHints: Option[Seq[String]] = None,
    federationEnabled: Option[Boolean] = None,
    federationJwks: Option[String] = None,
    federationSignatureKeyId: Option[String] = None,
    federationConfigurationDuration: Option[Int] = None,
    federationRegistrationEndpoint: Option[String] = None,
    organizationName: Option[String] = None,
    predefinedTransformedClaims: Option[String] = None,
    refreshTokenIdempotent: Option[Boolean] = None,
    signedJwksUri: Option[String] = None,
    supportedAttachments: Option[Seq[AttachmentType]] = None,
    supportedDigestAlgorithms: Option[Seq[String]] = None,
    supportedDocuments: Option[Seq[String]] = None,
    supportedDocumentsMethods: Option[Seq[String]] = None,
    supportedDocumentsValidationMethods: Option[Seq[String]] = None,
    supportedDocumentsVerificationMethods: Option[Seq[String]] = None,
    supportedElectronicRecords: Option[Seq[String]] = None,
    supportedClientRegistrationTypes: Option[Seq[ClientRegistrationType]] = None,
    tokenExchangeByIdentifiableClientsOnly: Option[Boolean] = None,
    tokenExchangeByConfidentialClientsOnly: Option[Boolean] = None,
    tokenExchangeByPermittedClientsOnly: Option[Boolean] = None,
    tokenExchangeEncryptedJwtRejected: Option[Boolean] = None,
    tokenExchangeUnsignedJwtRejected: Option[Boolean] = None,
    jwtGrantByIdentifiableClientsOnly: Option[Boolean] = None,
    jwtGrantEncryptedJwtRejected: Option[Boolean] = None,
    jwtGrantUnsignedJwtRejected: Option[Boolean] = None,
    dcrDuplicateSoftwareIdBlocked: Option[Boolean] = None,
    trustAnchors: Option[Seq[TrustAnchor]] = None,
    openidDroppedOnRefreshWithoutOfflineAccess: Option[Boolean] = None,
    supportedDocumentsCheckMethods: Option[Seq[String]] = None,
    rsResponseSigned: Option[Boolean] = None,
    resourceSignatureKeyId: Option[String] = None,
    idTokenAudType: Option[String] = None,
    idTokenReissuable: Option[Boolean] = None
)

object Service {

  given jsonCodec: JsonValueCodec[Service] = JsonCodecMaker.make(codecMakerConfig)

  given encoderService: Encoder[Service] = Encoder.instance { t =>
    Json.fromFields {
      Seq(
        t.number.map(v => "number" -> v.asJson),
        t.serviceOwnerNumber.map(v => "serviceOwnerNumber" -> v.asJson),
        t.serviceName.map(v => "serviceName" -> v.asJson),
        t.issuer.map(v => "issuer" -> v.asJson),
        t.description.map(v => "description" -> v.asJson),
        t.apiKey.map(v => "apiKey" -> v.asJson),
        t.apiSecret.map(v => "apiSecret" -> v.asJson),
        t.clientsPerDeveloper.map(v => "clientsPerDeveloper" -> v.asJson),
        t.clientIdAliasEnabled.map(v => "clientIdAliasEnabled" -> v.asJson),
        t.metadata.map(v => "metadata" -> v.asJson),
        t.createdAt.map(v => "createdAt" -> v.asJson),
        t.modifiedAt.map(v => "modifiedAt" -> v.asJson),
        t.authenticationCallbackEndpoint.map(v => "authenticationCallbackEndpoint" -> v.asJson),
        t.authenticationCallbackApiKey.map(v => "authenticationCallbackApiKey" -> v.asJson),
        t.authenticationCallbackApiSecret.map(v => "authenticationCallbackApiSecret" -> v.asJson),
        t.supportedSnses.map(v => "supportedSnses" -> v.asJson),
        t.snsCredentials.map(v => "snsCredentials" -> v.asJson),
        t.supportedAcrs.map(v => "supportedAcrs" -> v.asJson),
        t.developerAuthenticationCallbackEndpoint
          .map(v => "developerAuthenticationCallbackEndpoint" -> v.asJson),
        t.developerAuthenticationCallbackApiKey
          .map(v => "developerAuthenticationCallbackApiKey" -> v.asJson),
        t.developerAuthenticationCallbackApiSecret
          .map(v => "developerAuthenticationCallbackApiSecret" -> v.asJson),
        t.supportedDeveloperSnses.map(v => "supportedDeveloperSnses" -> v.asJson),
        t.developerSnsCredentials.map(v => "developerSnsCredentials" -> v.asJson),
        t.supportedGrantTypes.map(v => "supportedGrantTypes" -> v.asJson),
        t.supportedResponseTypes.map(v => "supportedResponseTypes" -> v.asJson),
        t.supportedAuthorizationDetailsTypes
          .map(v => "supportedAuthorizationDetailsTypes" -> v.asJson),
        t.supportedServiceProfiles.map(v => "supportedServiceProfiles" -> v.asJson),
        t.errorDescriptionOmitted.map(v => "errorDescriptionOmitted" -> v.asJson),
        t.errorUriOmitted.map(v => "errorUriOmitted" -> v.asJson),
        t.authorizationEndpoint.map(v => "authorizationEndpoint" -> v.asJson),
        t.directAuthorizationEndpointEnabled
          .map(v => "directAuthorizationEndpointEnabled" -> v.asJson),
        t.supportedUiLocales.map(v => "supportedUiLocales" -> v.asJson),
        t.supportedDisplays.map(v => "supportedDisplays" -> v.asJson),
        t.pkceRequired.map(v => "pkceRequired" -> v.asJson),
        t.pkceS256Required.map(v => "pkceS256Required" -> v.asJson),
        t.authorizationResponseDuration.map(v => "authorizationResponseDuration" -> v.asJson),
        t.tokenEndpoint.map(v => "tokenEndpoint" -> v.asJson),
        t.directTokenEndpointEnabled.map(v => "directTokenEndpointEnabled" -> v.asJson),
        t.supportedTokenAuthMethods.map(v => "supportedTokenAuthMethods" -> v.asJson),
        t.missingClientIdAllowed.map(v => "missingClientIdAllowed" -> v.asJson),
        t.revocationEndpoint.map(v => "revocationEndpoint" -> v.asJson),
        t.directRevocationEndpointEnabled.map(v => "directRevocationEndpointEnabled" -> v.asJson),
        t.supportedRevocationAuthMethods.map(v => "supportedRevocationAuthMethods" -> v.asJson),
        t.introspectionEndpoint.map(v => "introspectionEndpoint" -> v.asJson),
        t.directIntrospectionEndpointEnabled
          .map(v => "directIntrospectionEndpointEnabled" -> v.asJson),
        t.supportedIntrospectionAuthMethods
          .map(v => "supportedIntrospectionAuthMethods" -> v.asJson),
        t.pushedAuthReqEndpoint.map(v => "pushedAuthReqEndpoint" -> v.asJson),
        t.pushedAuthReqDuration.map(v => "pushedAuthReqDuration" -> v.asJson),
        t.parRequired.map(v => "parRequired" -> v.asJson),
        t.requestObjectRequired.map(v => "requestObjectRequired" -> v.asJson),
        t.traditionalRequestObjectProcessingApplied
          .map(v => "traditionalRequestObjectProcessingApplied" -> v.asJson),
        t.mutualTlsValidatePkiCertChain.map(v => "mutualTlsValidatePkiCertChain" -> v.asJson),
        t.trustedRootCertificates.map(v => "trustedRootCertificates" -> v.asJson),
        t.mtlsEndpointAliases.map(v => "mtlsEndpointAliases" -> v.asJson),
        t.accessTokenType.map(v => "accessTokenType" -> v.asJson),
        t.tlsClientCertificateBoundAccessTokens
          .map(v => "tlsClientCertificateBoundAccessTokens" -> v.asJson),
        t.accessTokenDuration.map(v => "accessTokenDuration" -> v.asJson),
        t.singleAccessTokenPerSubject.map(v => "singleAccessTokenPerSubject" -> v.asJson),
        t.accessTokenSignAlg.map(v => "accessTokenSignAlg" -> v.asJson),
        t.accessTokenSignatureKeyId.map(v => "accessTokenSignatureKeyId" -> v.asJson),
        t.refreshTokenDuration.map(v => "refreshTokenDuration" -> v.asJson),
        t.refreshTokenDurationKept.map(v => "refreshTokenDurationKept" -> v.asJson),
        t.refreshTokenDurationReset.map(v => "refreshTokenDurationReset" -> v.asJson),
        t.refreshTokenKept.map(v => "refreshTokenKept" -> v.asJson),
        t.supportedScopes.map(v => "supportedScopes" -> v.asJson),
        t.scopeRequired.map(v => "scopeRequired" -> v.asJson),
        t.idTokenDuration.map(v => "idTokenDuration" -> v.asJson),
        t.allowableClockSkew.map(v => "allowableClockSkew" -> v.asJson),
        t.supportedClaimTypes.map(v => "supportedClaimTypes" -> v.asJson),
        t.supportedClaimLocales.map(v => "supportedClaimLocales" -> v.asJson),
        t.supportedClaims.map(v => "supportedClaims" -> v.asJson),
        t.claimShortcutRestrictive.map(v => "claimShortcutRestrictive" -> v.asJson),
        t.jwksUri.map(v => "jwksUri" -> v.asJson),
        t.directJwksEndpointEnabled.map(v => "directJwksEndpointEnabled" -> v.asJson),
        t.jwks.map(v => "jwks" -> v.asJson),
        t.idTokenSignatureKeyId.map(v => "idTokenSignatureKeyId" -> v.asJson),
        t.userInfoSignatureKeyId.map(v => "userInfoSignatureKeyId" -> v.asJson),
        t.authorizationSignatureKeyId.map(v => "authorizationSignatureKeyId" -> v.asJson),
        t.userInfoEndpoint.map(v => "userInfoEndpoint" -> v.asJson),
        t.directUserInfoEndpointEnabled.map(v => "directUserInfoEndpointEnabled" -> v.asJson),
        t.dynamicRegistrationSupported.map(v => "dynamicRegistrationSupported" -> v.asJson),
        t.registrationEndpoint.map(v => "registrationEndpoint" -> v.asJson),
        t.registrationManagementEndpoint.map(v => "registrationManagementEndpoint" -> v.asJson),
        t.policyUri.map(v => "policyUri" -> v.asJson),
        t.tosUri.map(v => "tosUri" -> v.asJson),
        t.serviceDocumentation.map(v => "serviceDocumentation" -> v.asJson),
        t.backchannelAuthenticationEndpoint
          .map(v => "backchannelAuthenticationEndpoint" -> v.asJson),
        t.supportedBackchannelTokenDeliveryModes
          .map(v => "supportedBackchannelTokenDeliveryModes" -> v.asJson),
        t.backchannelAuthReqIdDuration.map(v => "backchannelAuthReqIdDuration" -> v.asJson),
        t.backchannelPollingInterval.map(v => "backchannelPollingInterval" -> v.asJson),
        t.backchannelUserCodeParameterSupported
          .map(v => "backchannelUserCodeParameterSupported" -> v.asJson),
        t.backchannelBindingMessageRequiredInFapi
          .map(v => "backchannelBindingMessageRequiredInFapi" -> v.asJson),
        t.deviceAuthorizationEndpoint.map(v => "deviceAuthorizationEndpoint" -> v.asJson),
        t.deviceVerificationUri.map(v => "deviceVerificationUri" -> v.asJson),
        t.deviceVerificationUriComplete.map(v => "deviceVerificationUriComplete" -> v.asJson),
        t.deviceFlowCodeDuration.map(v => "deviceFlowCodeDuration" -> v.asJson),
        t.deviceFlowPollingInterval.map(v => "deviceFlowPollingInterval" -> v.asJson),
        t.userCodeCharset.map(v => "userCodeCharset" -> v.asJson),
        t.userCodeLength.map(v => "userCodeLength" -> v.asJson),
        t.supportedTrustFrameworks.map(v => "supportedTrustFrameworks" -> v.asJson),
        t.supportedEvidence.map(v => "supportedEvidence" -> v.asJson),
        t.supportedIdentityDocuments.map(v => "supportedIdentityDocuments" -> v.asJson),
        t.supportedVerificationMethods.map(v => "supportedVerificationMethods" -> v.asJson),
        t.supportedVerifiedClaims.map(v => "supportedVerifiedClaims" -> v.asJson),
        t.verifiedClaimsValidationSchemaSet
          .map(v => "verifiedClaimsValidationSchemaSet" -> v.asJson),
        t.attributes.map(v => "attributes" -> v.asJson),
        t.nbfOptional.map(v => "nbfOptional" -> v.asJson),
        t.issSuppressed.map(v => "issSuppressed" -> v.asJson),
        t.supportedCustomClientMetadata.map(v => "supportedCustomClientMetadata" -> v.asJson),
        t.tokenExpirationLinked.map(v => "tokenExpirationLinked" -> v.asJson),
        t.frontChannelRequestObjectEncryptionRequired
          .map(v => "frontChannelRequestObjectEncryptionRequired" -> v.asJson),
        t.requestObjectEncryptionAlgMatchRequired
          .map(v => "requestObjectEncryptionAlgMatchRequired" -> v.asJson),
        t.requestObjectEncryptionEncMatchRequired
          .map(v => "requestObjectEncryptionEncMatchRequired" -> v.asJson),
        t.hsmEnabled.map(v => "hsmEnabled" -> v.asJson),
        t.hsks.map(v => "hsks" -> v.asJson),
        t.grantManagementEndpoint.map(v => "grantManagementEndpoint" -> v.asJson),
        t.grantManagementActionRequired.map(v => "grantManagementActionRequired" -> v.asJson),
        t.unauthorizedOnClientConfigSupported
          .map(v => "unauthorizedOnClientConfigSupported" -> v.asJson),
        t.dcrScopeUsedAsRequestable.map(v => "dcrScopeUsedAsRequestable" -> v.asJson),
        t.endSessionEndpoint.map(v => "endSessionEndpoint" -> v.asJson),
        t.loopbackRedirectionUriVariable.map(v => "loopbackRedirectionUriVariable" -> v.asJson),
        t.requestObjectAudienceChecked.map(v => "requestObjectAudienceChecked" -> v.asJson),
        t.accessTokenForExternalAttachmentEmbedded
          .map(v => "accessTokenForExternalAttachmentEmbedded" -> v.asJson),
        t.authorityHints.map(v => "authorityHints" -> v.asJson),
        t.federationEnabled.map(v => "federationEnabled" -> v.asJson),
        t.federationJwks.map(v => "federationJwks" -> v.asJson),
        t.federationSignatureKeyId.map(v => "federationSignatureKeyId" -> v.asJson),
        t.federationConfigurationDuration.map(v => "federationConfigurationDuration" -> v.asJson),
        t.federationRegistrationEndpoint.map(v => "federationRegistrationEndpoint" -> v.asJson),
        t.organizationName.map(v => "organizationName" -> v.asJson),
        t.predefinedTransformedClaims.map(v => "predefinedTransformedClaims" -> v.asJson),
        t.refreshTokenIdempotent.map(v => "refreshTokenIdempotent" -> v.asJson),
        t.signedJwksUri.map(v => "signedJwksUri" -> v.asJson),
        t.supportedAttachments.map(v => "supportedAttachments" -> v.asJson),
        t.supportedDigestAlgorithms.map(v => "supportedDigestAlgorithms" -> v.asJson),
        t.supportedDocuments.map(v => "supportedDocuments" -> v.asJson),
        t.supportedDocumentsMethods.map(v => "supportedDocumentsMethods" -> v.asJson),
        t.supportedDocumentsValidationMethods
          .map(v => "supportedDocumentsValidationMethods" -> v.asJson),
        t.supportedDocumentsVerificationMethods
          .map(v => "supportedDocumentsVerificationMethods" -> v.asJson),
        t.supportedElectronicRecords.map(v => "supportedElectronicRecords" -> v.asJson),
        t.supportedClientRegistrationTypes.map(v => "supportedClientRegistrationTypes" -> v.asJson),
        t.tokenExchangeByIdentifiableClientsOnly
          .map(v => "tokenExchangeByIdentifiableClientsOnly" -> v.asJson),
        t.tokenExchangeByConfidentialClientsOnly
          .map(v => "tokenExchangeByConfidentialClientsOnly" -> v.asJson),
        t.tokenExchangeByPermittedClientsOnly
          .map(v => "tokenExchangeByPermittedClientsOnly" -> v.asJson),
        t.tokenExchangeEncryptedJwtRejected
          .map(v => "tokenExchangeEncryptedJwtRejected" -> v.asJson),
        t.tokenExchangeUnsignedJwtRejected.map(v => "tokenExchangeUnsignedJwtRejected" -> v.asJson),
        t.jwtGrantByIdentifiableClientsOnly
          .map(v => "jwtGrantByIdentifiableClientsOnly" -> v.asJson),
        t.jwtGrantEncryptedJwtRejected.map(v => "jwtGrantEncryptedJwtRejected" -> v.asJson),
        t.jwtGrantUnsignedJwtRejected.map(v => "jwtGrantUnsignedJwtRejected" -> v.asJson),
        t.dcrDuplicateSoftwareIdBlocked.map(v => "dcrDuplicateSoftwareIdBlocked" -> v.asJson),
        t.trustAnchors.map(v => "trustAnchors" -> v.asJson),
        t.openidDroppedOnRefreshWithoutOfflineAccess
          .map(v => "openidDroppedOnRefreshWithoutOfflineAccess" -> v.asJson),
        t.supportedDocumentsCheckMethods.map(v => "supportedDocumentsCheckMethods" -> v.asJson),
        t.rsResponseSigned.map(v => "rsResponseSigned" -> v.asJson),
        t.resourceSignatureKeyId.map(v => "resourceSignatureKeyId" -> v.asJson),
        t.idTokenAudType.map(v => "idTokenAudType" -> v.asJson),
        t.idTokenReissuable.map(v => "idTokenReissuable" -> v.asJson)
      ).flatten
    }
  }

  given decoderService: Decoder[Service] = Decoder.instance { c =>
    for {
      number               <- c.downField("number").as[Option[Int]]
      serviceOwnerNumber   <- c.downField("serviceOwnerNumber").as[Option[Int]]
      serviceName          <- c.downField("serviceName").as[Option[String]]
      issuer               <- c.downField("issuer").as[Option[String]]
      description          <- c.downField("description").as[Option[String]]
      apiKey               <- c.downField("apiKey").as[Option[Long]]
      apiSecret            <- c.downField("apiSecret").as[Option[String]]
      clientsPerDeveloper  <- c.downField("clientsPerDeveloper").as[Option[Int]]
      clientIdAliasEnabled <- c.downField("clientIdAliasEnabled").as[Option[Boolean]]
      metadata             <- c.downField("metadata").as[Option[Seq[Pair]]]
      createdAt            <- c.downField("createdAt").as[Option[Long]]
      modifiedAt           <- c.downField("modifiedAt").as[Option[Long]]
      authenticationCallbackEndpoint <-
        c.downField("authenticationCallbackEndpoint").as[Option[URI]]
      authenticationCallbackApiKey <- c.downField("authenticationCallbackApiKey").as[Option[String]]
      authenticationCallbackApiSecret <-
        c.downField("authenticationCallbackApiSecret").as[Option[String]]
      supportedSnses <- c.downField("supportedSnses").as[Option[Seq[Sns]]]
      snsCredentials <- c.downField("snsCredentials").as[Option[Seq[SnsCredentials]]]
      supportedAcrs  <- c.downField("supportedAcrs").as[Option[Seq[String]]]
      developerAuthenticationCallbackEndpoint <-
        c.downField("developerAuthenticationCallbackEndpoint").as[Option[URI]]
      developerAuthenticationCallbackApiKey <-
        c.downField("developerAuthenticationCallbackApiKey").as[Option[String]]
      developerAuthenticationCallbackApiSecret <-
        c.downField("developerAuthenticationCallbackApiSecret").as[Option[String]]
      supportedDeveloperSnses <- c.downField("supportedDeveloperSnses").as[Option[Seq[Sns]]]
      developerSnsCredentials <-
        c.downField("developerSnsCredentials").as[Option[Seq[SnsCredentials]]]
      supportedGrantTypes    <- c.downField("supportedGrantTypes").as[Option[Seq[GrantType]]]
      supportedResponseTypes <- c.downField("supportedResponseTypes").as[Option[Seq[ResponseType]]]
      supportedAuthorizationDetailsTypes <-
        c.downField("supportedAuthorizationDetailsTypes").as[Option[Seq[String]]]
      supportedServiceProfiles <-
        c.downField("supportedServiceProfiles").as[Option[Seq[ServiceProfile]]]
      errorDescriptionOmitted <- c.downField("errorDescriptionOmitted").as[Option[Boolean]]
      errorUriOmitted         <- c.downField("errorUriOmitted").as[Option[Boolean]]
      authorizationEndpoint   <- c.downField("authorizationEndpoint").as[Option[URI]]
      directAuthorizationEndpointEnabled <-
        c.downField("directAuthorizationEndpointEnabled").as[Option[Boolean]]
      supportedUiLocales            <- c.downField("supportedUiLocales").as[Option[Seq[String]]]
      supportedDisplays             <- c.downField("supportedDisplays").as[Option[Seq[Display]]]
      pkceRequired                  <- c.downField("pkceRequired").as[Option[Boolean]]
      pkceS256Required              <- c.downField("pkceS256Required").as[Option[Boolean]]
      authorizationResponseDuration <- c.downField("authorizationResponseDuration").as[Option[Long]]
      tokenEndpoint                 <- c.downField("tokenEndpoint").as[Option[URI]]
      directTokenEndpointEnabled    <- c.downField("directTokenEndpointEnabled").as[Option[Boolean]]
      supportedTokenAuthMethods <-
        c.downField("supportedTokenAuthMethods").as[Option[Seq[ClientAuthMethod]]]
      missingClientIdAllowed <- c.downField("missingClientIdAllowed").as[Option[Boolean]]
      revocationEndpoint     <- c.downField("revocationEndpoint").as[Option[URI]]
      directRevocationEndpointEnabled <-
        c.downField("directRevocationEndpointEnabled").as[Option[Boolean]]
      supportedRevocationAuthMethods <-
        c.downField("supportedRevocationAuthMethods").as[Option[Seq[ClientAuthMethod]]]
      introspectionEndpoint <- c.downField("introspectionEndpoint").as[Option[URI]]
      directIntrospectionEndpointEnabled <-
        c.downField("directIntrospectionEndpointEnabled").as[Option[Boolean]]
      supportedIntrospectionAuthMethods <-
        c.downField("supportedIntrospectionAuthMethods").as[Option[Seq[ClientAuthMethod]]]
      pushedAuthReqEndpoint <- c.downField("pushedAuthReqEndpoint").as[Option[URI]]
      pushedAuthReqDuration <- c.downField("pushedAuthReqDuration").as[Option[Long]]
      parRequired           <- c.downField("parRequired").as[Option[Boolean]]
      requestObjectRequired <- c.downField("requestObjectRequired").as[Option[Boolean]]
      traditionalRequestObjectProcessingApplied <-
        c.downField("traditionalRequestObjectProcessingApplied").as[Option[Boolean]]
      mutualTlsValidatePkiCertChain <-
        c.downField("mutualTlsValidatePkiCertChain").as[Option[Boolean]]
      trustedRootCertificates <- c.downField("trustedRootCertificates").as[Option[Seq[String]]]
      mtlsEndpointAliases     <- c.downField("mtlsEndpointAliases").as[Option[Seq[NamedUri]]]
      accessTokenType         <- c.downField("accessTokenType").as[Option[String]]
      tlsClientCertificateBoundAccessTokens <-
        c.downField("tlsClientCertificateBoundAccessTokens").as[Option[Boolean]]
      accessTokenDuration         <- c.downField("accessTokenDuration").as[Option[Long]]
      singleAccessTokenPerSubject <- c.downField("singleAccessTokenPerSubject").as[Option[Boolean]]
      accessTokenSignAlg <-
        mapEmptyStringToNull(c.downField("accessTokenSignAlg")).as[Option[JwsAlg]]
      accessTokenSignatureKeyId   <- c.downField("accessTokenSignatureKeyId").as[Option[String]]
      refreshTokenDuration        <- c.downField("refreshTokenDuration").as[Option[Long]]
      refreshTokenDurationKept    <- c.downField("refreshTokenDurationKept").as[Option[Boolean]]
      refreshTokenDurationReset   <- c.downField("refreshTokenDurationReset").as[Option[Boolean]]
      refreshTokenKept            <- c.downField("refreshTokenKept").as[Option[Boolean]]
      supportedScopes             <- c.downField("supportedScopes").as[Option[Seq[Scope]]]
      scopeRequired               <- c.downField("scopeRequired").as[Option[Boolean]]
      idTokenDuration             <- c.downField("idTokenDuration").as[Option[Long]]
      allowableClockSkew          <- c.downField("allowableClockSkew").as[Option[Int]]
      supportedClaimTypes         <- c.downField("supportedClaimTypes").as[Option[Seq[ClaimType]]]
      supportedClaimLocales       <- c.downField("supportedClaimLocales").as[Option[Seq[String]]]
      supportedClaims             <- c.downField("supportedClaims").as[Option[Seq[String]]]
      claimShortcutRestrictive    <- c.downField("claimShortcutRestrictive").as[Option[Boolean]]
      jwksUri                     <- c.downField("jwksUri").as[Option[URI]]
      directJwksEndpointEnabled   <- c.downField("directJwksEndpointEnabled").as[Option[Boolean]]
      jwks                        <- c.downField("jwks").as[Option[String]]
      idTokenSignatureKeyId       <- c.downField("idTokenSignatureKeyId").as[Option[String]]
      userInfoSignatureKeyId      <- c.downField("userInfoSignatureKeyId").as[Option[String]]
      authorizationSignatureKeyId <- c.downField("authorizationSignatureKeyId").as[Option[String]]
      userInfoEndpoint            <- c.downField("userInfoEndpoint").as[Option[URI]]
      directUserInfoEndpointEnabled <-
        c.downField("directUserInfoEndpointEnabled").as[Option[Boolean]]
      dynamicRegistrationSupported <-
        c.downField("dynamicRegistrationSupported").as[Option[Boolean]]
      registrationEndpoint <- c.downField("registrationEndpoint").as[Option[URI]]
      registrationManagementEndpoint <-
        c.downField("registrationManagementEndpoint").as[Option[URI]]
      policyUri            <- c.downField("policyUri").as[Option[URI]]
      tosUri               <- c.downField("tosUri").as[Option[URI]]
      serviceDocumentation <- c.downField("serviceDocumentation").as[Option[URI]]
      backchannelAuthenticationEndpoint <-
        c.downField("backchannelAuthenticationEndpoint").as[Option[URI]]
      supportedBackchannelTokenDeliveryModes <-
        c.downField("supportedBackchannelTokenDeliveryModes").as[Option[Seq[DeliveryMode]]]
      backchannelAuthReqIdDuration <- c.downField("backchannelAuthReqIdDuration").as[Option[Int]]
      backchannelPollingInterval   <- c.downField("backchannelPollingInterval").as[Option[Int]]
      backchannelUserCodeParameterSupported <-
        c.downField("backchannelUserCodeParameterSupported").as[Option[Boolean]]
      backchannelBindingMessageRequiredInFapi <-
        c.downField("backchannelBindingMessageRequiredInFapi").as[Option[Boolean]]
      deviceAuthorizationEndpoint   <- c.downField("deviceAuthorizationEndpoint").as[Option[URI]]
      deviceVerificationUri         <- c.downField("deviceVerificationUri").as[Option[URI]]
      deviceVerificationUriComplete <- c.downField("deviceVerificationUriComplete").as[Option[URI]]
      deviceFlowCodeDuration        <- c.downField("deviceFlowCodeDuration").as[Option[Int]]
      deviceFlowPollingInterval     <- c.downField("deviceFlowPollingInterval").as[Option[Int]]
      userCodeCharset <-
        mapEmptyStringToNull(c.downField("userCodeCharset")).as[Option[UserCodeCharset]]
      userCodeLength           <- c.downField("userCodeLength").as[Option[Int]]
      supportedTrustFrameworks <- c.downField("supportedTrustFrameworks").as[Option[Seq[String]]]
      supportedEvidence        <- c.downField("supportedEvidence").as[Option[Seq[String]]]
      supportedIdentityDocuments <-
        c.downField("supportedIdentityDocuments").as[Option[Seq[String]]]
      supportedVerificationMethods <-
        c.downField("supportedVerificationMethods").as[Option[Seq[String]]]
      supportedVerifiedClaims <- c.downField("supportedVerifiedClaims").as[Option[Seq[String]]]
      verifiedClaimsValidationSchemaSet <- mapEmptyStringToNull(
                                             c.downField("verifiedClaimsValidationSchemaSet")
                                           ).as[Option[VerifiedClaimsValidationSchema]]
      attributes    <- c.downField("attributes").as[Option[Seq[Pair]]]
      nbfOptional   <- c.downField("nbfOptional").as[Option[Boolean]]
      issSuppressed <- c.downField("issSuppressed").as[Option[Boolean]]
      supportedCustomClientMetadata <-
        c.downField("supportedCustomClientMetadata").as[Option[Seq[String]]]
      tokenExpirationLinked <- c.downField("tokenExpirationLinked").as[Option[Boolean]]
      frontChannelRequestObjectEncryptionRequired <-
        c.downField("frontChannelRequestObjectEncryptionRequired").as[Option[Boolean]]
      requestObjectEncryptionAlgMatchRequired <-
        c.downField("requestObjectEncryptionAlgMatchRequired").as[Option[Boolean]]
      requestObjectEncryptionEncMatchRequired <-
        c.downField("requestObjectEncryptionEncMatchRequired").as[Option[Boolean]]
      hsmEnabled              <- c.downField("hsmEnabled").as[Option[Boolean]]
      hsks                    <- c.downField("hsks").as[Option[Seq[Hsk]]]
      grantManagementEndpoint <- c.downField("grantManagementEndpoint").as[Option[String]]
      grantManagementActionRequired <-
        c.downField("grantManagementActionRequired").as[Option[Boolean]]
      unauthorizedOnClientConfigSupported <-
        c.downField("unauthorizedOnClientConfigSupported").as[Option[Boolean]]
      dcrScopeUsedAsRequestable <- c.downField("dcrScopeUsedAsRequestable").as[Option[Boolean]]
      endSessionEndpoint        <- c.downField("endSessionEndpoint").as[Option[URI]]
      loopbackRedirectionUriVariable <-
        c.downField("loopbackRedirectionUriVariable").as[Option[Boolean]]
      requestObjectAudienceChecked <-
        c.downField("requestObjectAudienceChecked").as[Option[Boolean]]
      accessTokenForExternalAttachmentEmbedded <-
        c.downField("accessTokenForExternalAttachmentEmbedded").as[Option[Boolean]]
      authorityHints           <- c.downField("authorityHints").as[Option[Seq[String]]]
      federationEnabled        <- c.downField("federationEnabled").as[Option[Boolean]]
      federationJwks           <- c.downField("federationJwks").as[Option[String]]
      federationSignatureKeyId <- c.downField("federationSignatureKeyId").as[Option[String]]
      federationConfigurationDuration <-
        c.downField("federationConfigurationDuration").as[Option[Int]]
      federationRegistrationEndpoint <-
        c.downField("federationRegistrationEndpoint").as[Option[String]]
      organizationName            <- c.downField("organizationName").as[Option[String]]
      predefinedTransformedClaims <- c.downField("predefinedTransformedClaims").as[Option[String]]
      refreshTokenIdempotent      <- c.downField("refreshTokenIdempotent").as[Option[Boolean]]
      signedJwksUri               <- c.downField("signedJwksUri").as[Option[String]]
      supportedAttachments        <- c.downField("supportedAttachments").as[Option[Seq[AttachmentType]]]
      supportedDigestAlgorithms   <- c.downField("supportedDigestAlgorithms").as[Option[Seq[String]]]
      supportedDocuments          <- c.downField("supportedDocuments").as[Option[Seq[String]]]
      supportedDocumentsMethods   <- c.downField("supportedDocumentsMethods").as[Option[Seq[String]]]
      supportedDocumentsValidationMethods <-
        c.downField("supportedDocumentsValidationMethods").as[Option[Seq[String]]]
      supportedDocumentsVerificationMethods <-
        c.downField("supportedDocumentsVerificationMethods").as[Option[Seq[String]]]
      supportedElectronicRecords <-
        c.downField("supportedElectronicRecords").as[Option[Seq[String]]]
      supportedClientRegistrationTypes <-
        c.downField("supportedClientRegistrationTypes").as[Option[Seq[ClientRegistrationType]]]
      tokenExchangeByIdentifiableClientsOnly <-
        c.downField("tokenExchangeByIdentifiableClientsOnly").as[Option[Boolean]]
      tokenExchangeByConfidentialClientsOnly <-
        c.downField("tokenExchangeByConfidentialClientsOnly").as[Option[Boolean]]
      tokenExchangeByPermittedClientsOnly <-
        c.downField("tokenExchangeByPermittedClientsOnly").as[Option[Boolean]]
      tokenExchangeEncryptedJwtRejected <-
        c.downField("tokenExchangeEncryptedJwtRejected").as[Option[Boolean]]
      tokenExchangeUnsignedJwtRejected <-
        c.downField("tokenExchangeUnsignedJwtRejected").as[Option[Boolean]]
      jwtGrantByIdentifiableClientsOnly <-
        c.downField("jwtGrantByIdentifiableClientsOnly").as[Option[Boolean]]
      jwtGrantEncryptedJwtRejected <-
        c.downField("jwtGrantEncryptedJwtRejected").as[Option[Boolean]]
      jwtGrantUnsignedJwtRejected <- c.downField("jwtGrantUnsignedJwtRejected").as[Option[Boolean]]
      dcrDuplicateSoftwareIdBlocked <-
        c.downField("dcrDuplicateSoftwareIdBlocked").as[Option[Boolean]]
      trustAnchors <- c.downField("trustAnchors").as[Option[Seq[TrustAnchor]]]
      openidDroppedOnRefreshWithoutOfflineAccess <-
        c.downField("openidDroppedOnRefreshWithoutOfflineAccess").as[Option[Boolean]]
      supportedDocumentsCheckMethods <-
        c.downField("supportedDocumentsCheckMethods").as[Option[Seq[String]]]
      rsResponseSigned       <- c.downField("rsResponseSigned").as[Option[Boolean]]
      resourceSignatureKeyId <- c.downField("resourceSignatureKeyId").as[Option[String]]
      idTokenAudType         <- c.downField("idTokenAudType").as[Option[String]]
      idTokenReissuable      <- c.downField("idTokenReissuable").as[Option[Boolean]]
    } yield Service(
      number = number,
      serviceOwnerNumber = serviceOwnerNumber,
      serviceName = serviceName,
      issuer = issuer,
      description = description,
      apiKey = apiKey,
      apiSecret = apiSecret,
      clientsPerDeveloper = clientsPerDeveloper,
      clientIdAliasEnabled = clientIdAliasEnabled,
      metadata = metadata,
      createdAt = createdAt,
      modifiedAt = modifiedAt,
      authenticationCallbackEndpoint = authenticationCallbackEndpoint,
      authenticationCallbackApiKey = authenticationCallbackApiKey,
      authenticationCallbackApiSecret = authenticationCallbackApiSecret,
      supportedSnses = supportedSnses,
      snsCredentials = snsCredentials,
      supportedAcrs = supportedAcrs,
      developerAuthenticationCallbackEndpoint = developerAuthenticationCallbackEndpoint,
      developerAuthenticationCallbackApiKey = developerAuthenticationCallbackApiKey,
      developerAuthenticationCallbackApiSecret = developerAuthenticationCallbackApiSecret,
      supportedDeveloperSnses = supportedDeveloperSnses,
      developerSnsCredentials = developerSnsCredentials,
      supportedGrantTypes = supportedGrantTypes,
      supportedResponseTypes = supportedResponseTypes,
      supportedAuthorizationDetailsTypes = supportedAuthorizationDetailsTypes,
      supportedServiceProfiles = supportedServiceProfiles,
      errorDescriptionOmitted = errorDescriptionOmitted,
      errorUriOmitted = errorUriOmitted,
      authorizationEndpoint = authorizationEndpoint,
      directAuthorizationEndpointEnabled = directAuthorizationEndpointEnabled,
      supportedUiLocales = supportedUiLocales,
      supportedDisplays = supportedDisplays,
      pkceRequired = pkceRequired,
      pkceS256Required = pkceS256Required,
      authorizationResponseDuration = authorizationResponseDuration,
      tokenEndpoint = tokenEndpoint,
      directTokenEndpointEnabled = directTokenEndpointEnabled,
      supportedTokenAuthMethods = supportedTokenAuthMethods,
      missingClientIdAllowed = missingClientIdAllowed,
      revocationEndpoint = revocationEndpoint,
      directRevocationEndpointEnabled = directRevocationEndpointEnabled,
      supportedRevocationAuthMethods = supportedRevocationAuthMethods,
      introspectionEndpoint = introspectionEndpoint,
      directIntrospectionEndpointEnabled = directIntrospectionEndpointEnabled,
      supportedIntrospectionAuthMethods = supportedIntrospectionAuthMethods,
      pushedAuthReqEndpoint = pushedAuthReqEndpoint,
      pushedAuthReqDuration = pushedAuthReqDuration,
      parRequired = parRequired,
      requestObjectRequired = requestObjectRequired,
      traditionalRequestObjectProcessingApplied = traditionalRequestObjectProcessingApplied,
      mutualTlsValidatePkiCertChain = mutualTlsValidatePkiCertChain,
      trustedRootCertificates = trustedRootCertificates,
      mtlsEndpointAliases = mtlsEndpointAliases,
      accessTokenType = accessTokenType,
      tlsClientCertificateBoundAccessTokens = tlsClientCertificateBoundAccessTokens,
      accessTokenDuration = accessTokenDuration,
      singleAccessTokenPerSubject = singleAccessTokenPerSubject,
      accessTokenSignAlg = accessTokenSignAlg,
      accessTokenSignatureKeyId = accessTokenSignatureKeyId,
      refreshTokenDuration = refreshTokenDuration,
      refreshTokenDurationKept = refreshTokenDurationKept,
      refreshTokenDurationReset = refreshTokenDurationReset,
      refreshTokenKept = refreshTokenKept,
      supportedScopes = supportedScopes,
      scopeRequired = scopeRequired,
      idTokenDuration = idTokenDuration,
      allowableClockSkew = allowableClockSkew,
      supportedClaimTypes = supportedClaimTypes,
      supportedClaimLocales = supportedClaimLocales,
      supportedClaims = supportedClaims,
      claimShortcutRestrictive = claimShortcutRestrictive,
      jwksUri = jwksUri,
      directJwksEndpointEnabled = directJwksEndpointEnabled,
      jwks = jwks,
      idTokenSignatureKeyId = idTokenSignatureKeyId,
      userInfoSignatureKeyId = userInfoSignatureKeyId,
      authorizationSignatureKeyId = authorizationSignatureKeyId,
      userInfoEndpoint = userInfoEndpoint,
      directUserInfoEndpointEnabled = directUserInfoEndpointEnabled,
      dynamicRegistrationSupported = dynamicRegistrationSupported,
      registrationEndpoint = registrationEndpoint,
      registrationManagementEndpoint = registrationManagementEndpoint,
      policyUri = policyUri,
      tosUri = tosUri,
      serviceDocumentation = serviceDocumentation,
      backchannelAuthenticationEndpoint = backchannelAuthenticationEndpoint,
      supportedBackchannelTokenDeliveryModes = supportedBackchannelTokenDeliveryModes,
      backchannelAuthReqIdDuration = backchannelAuthReqIdDuration,
      backchannelPollingInterval = backchannelPollingInterval,
      backchannelUserCodeParameterSupported = backchannelUserCodeParameterSupported,
      backchannelBindingMessageRequiredInFapi = backchannelBindingMessageRequiredInFapi,
      deviceAuthorizationEndpoint = deviceAuthorizationEndpoint,
      deviceVerificationUri = deviceVerificationUri,
      deviceVerificationUriComplete = deviceVerificationUriComplete,
      deviceFlowCodeDuration = deviceFlowCodeDuration,
      deviceFlowPollingInterval = deviceFlowPollingInterval,
      userCodeCharset = userCodeCharset,
      userCodeLength = userCodeLength,
      supportedTrustFrameworks = supportedTrustFrameworks,
      supportedEvidence = supportedEvidence,
      supportedIdentityDocuments = supportedIdentityDocuments,
      supportedVerificationMethods = supportedVerificationMethods,
      supportedVerifiedClaims = supportedVerifiedClaims,
      verifiedClaimsValidationSchemaSet = verifiedClaimsValidationSchemaSet,
      attributes = attributes,
      nbfOptional = nbfOptional,
      issSuppressed = issSuppressed,
      supportedCustomClientMetadata = supportedCustomClientMetadata,
      tokenExpirationLinked = tokenExpirationLinked,
      frontChannelRequestObjectEncryptionRequired = frontChannelRequestObjectEncryptionRequired,
      requestObjectEncryptionAlgMatchRequired = requestObjectEncryptionAlgMatchRequired,
      requestObjectEncryptionEncMatchRequired = requestObjectEncryptionEncMatchRequired,
      hsmEnabled = hsmEnabled,
      hsks = hsks,
      grantManagementEndpoint = grantManagementEndpoint,
      grantManagementActionRequired = grantManagementActionRequired,
      unauthorizedOnClientConfigSupported = unauthorizedOnClientConfigSupported,
      dcrScopeUsedAsRequestable = dcrScopeUsedAsRequestable,
      endSessionEndpoint = endSessionEndpoint,
      loopbackRedirectionUriVariable = loopbackRedirectionUriVariable,
      requestObjectAudienceChecked = requestObjectAudienceChecked,
      accessTokenForExternalAttachmentEmbedded = accessTokenForExternalAttachmentEmbedded,
      authorityHints = authorityHints,
      federationEnabled = federationEnabled,
      federationJwks = federationJwks,
      federationSignatureKeyId = federationSignatureKeyId,
      federationConfigurationDuration = federationConfigurationDuration,
      federationRegistrationEndpoint = federationRegistrationEndpoint,
      organizationName = organizationName,
      predefinedTransformedClaims = predefinedTransformedClaims,
      refreshTokenIdempotent = refreshTokenIdempotent,
      signedJwksUri = signedJwksUri,
      supportedAttachments = supportedAttachments,
      supportedDigestAlgorithms = supportedDigestAlgorithms,
      supportedDocuments = supportedDocuments,
      supportedDocumentsMethods = supportedDocumentsMethods,
      supportedDocumentsValidationMethods = supportedDocumentsValidationMethods,
      supportedDocumentsVerificationMethods = supportedDocumentsVerificationMethods,
      supportedElectronicRecords = supportedElectronicRecords,
      supportedClientRegistrationTypes = supportedClientRegistrationTypes,
      tokenExchangeByIdentifiableClientsOnly = tokenExchangeByIdentifiableClientsOnly,
      tokenExchangeByConfidentialClientsOnly = tokenExchangeByConfidentialClientsOnly,
      tokenExchangeByPermittedClientsOnly = tokenExchangeByPermittedClientsOnly,
      tokenExchangeEncryptedJwtRejected = tokenExchangeEncryptedJwtRejected,
      tokenExchangeUnsignedJwtRejected = tokenExchangeUnsignedJwtRejected,
      jwtGrantByIdentifiableClientsOnly = jwtGrantByIdentifiableClientsOnly,
      jwtGrantEncryptedJwtRejected = jwtGrantEncryptedJwtRejected,
      jwtGrantUnsignedJwtRejected = jwtGrantUnsignedJwtRejected,
      dcrDuplicateSoftwareIdBlocked = dcrDuplicateSoftwareIdBlocked,
      trustAnchors = trustAnchors,
      openidDroppedOnRefreshWithoutOfflineAccess = openidDroppedOnRefreshWithoutOfflineAccess,
      supportedDocumentsCheckMethods = supportedDocumentsCheckMethods,
      rsResponseSigned = rsResponseSigned,
      resourceSignatureKeyId = resourceSignatureKeyId,
      idTokenAudType = idTokenAudType,
      idTokenReissuable = idTokenReissuable
    )
  }

}
