/**
  * Authlete API Authlete API Document.
  *
  * The version of the OpenAPI document: 2.3.12 Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package authlete
package models

import scala.collection.immutable.Seq

import com.github.plokhotnyuk.jsoniter_scala.core.JsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.ConfiguredJsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMaker
import io.circe.{Decoder, Encoder, Json}
import io.circe.syntax.*

/**
  * @param resultCode
  *   The code which represents the result of the API call.
  * @param resultMessage
  *   A short message which explains the result of the API call.
  * @param action
  * @param responseContent
  *   The content that the authorization server implementation is to return to the client
  *   application. Its format varies depending on the value of `action` parameter.
  * @param username
  *   The value of `username` request parameter in the token request. The client application must
  *   specify username when it uses [Resource Owner Password
  *   Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.3). In other words, when the
  *   value of `grant_type` request parameter is `password`, `username` request parameter must come
  *   along. This parameter has a value only if the value of `grant_type` request parameter is
  *   `password` and the token request is valid.
  * @param password
  *   The value of `password` request parameter in the token request. The client application must
  *   specify password when it uses [Resource Owner Password
  *   Grant](https://datatracker.ietf.org/doc/html/rfc6749#section-4.3). In other words, when the
  *   value of `grant_type` request parameter is `password`, `password` request parameter must come
  *   along. This parameter has a value only if the value of `grant_type` request parameter is
  *   `password` and the token request is valid.
  * @param ticket
  *   The ticket which is necessary to call Authlete's `/auth/token/fail` API or `/auth/token/issue`
  *   API. This parameter has a value only if the value of `grant_type` request parameter is
  *   `password` and the token request is valid.
  * @param accessToken
  *   The newly issued access token.
  * @param accessTokenExpiresAt
  *   The datetime at which the newly issued access token will expire. The value is represented in
  *   milliseconds since the Unix epoch (1970-01-01).
  * @param accessTokenDuration
  *   The duration of the newly issued access token in seconds.
  * @param refreshToken
  *   The newly issued refresh token.
  * @param refreshTokenExpiresAt
  *   The datetime at which the newly issued refresh token will expire. The value is represented in
  *   milliseconds since the Unix epoch (1970-01-01).
  * @param refreshTokenDuration
  *   The duration of the newly issued refresh token in seconds.
  * @param idToken
  *   The newly issued ID token. Note that an ID token is issued from a token endpoint only when the
  *   `response_type` request parameter of the authorization request to an authorization endpoint
  *   has contained `code` and the `scope` request parameter has contained `openid`.
  * @param grantType
  *   The grant type of the token request.
  * @param clientId
  *   The client ID.
  * @param clientIdAlias
  *   The client ID alias when the token request was made. If the client did not have an alias, this
  *   parameter is `null`. Also, if the token request was invalid and it failed to identify a
  *   client, this parameter is `null`.
  * @param clientIdAliasUsed
  *   The flag which indicates whether the client ID alias was used when the token request was made.
  *   `true` if the client ID alias was used when the token request was made.
  * @param subject
  *   The subject (= resource owner's ID) of the access token. Even if an access token has been
  *   issued by the call of `/api/auth/token` API, this parameter is `null` if the flow of the token
  *   request was [Client Credentials
  *   Flow](https://datatracker.ietf.org/doc/html/rfc6749#section-4.4)
  *   (`grant_type=client_credentials`) because it means the access token is not associated with any
  *   specific end-user.
  * @param scopes
  *   The scopes covered by the access token.
  * @param properties
  *   The extra properties associated with the access token. This parameter is `null` when no extra
  *   property is associated with the issued access token.
  * @param jwtAccessToken
  *   The newly issued access token in JWT format. If the authorization server is configured to
  *   issue JWT-based access tokens (= if the service's `accessTokenSignAlg` value is a non-null
  *   value), a JWT-based access token is issued along with the original random-string one.
  * @param resources
  *   The resources specified by the `resource` request parameters in the token request. See
  *   \"Resource Indicators for OAuth 2.0\" for details.
  * @param accessTokenResources
  *   The target resources of the access token being issued. See \"Resource Indicators for OAuth
  *   2.0\" for details.
  * @param authorizationDetails
  * @param serviceAttributes
  *   The attributes of this service that the client application belongs to.
  * @param clientAttributes
  *   The attributes of the client.
  * @param grantId
  *   the value of the `grant_id` request parameter of the device authorization request. The
  *   `grant_id` request parameter is defined in [Grant Management for OAuth
  *   2.0](https://openid.net/specs/fapi-grant-management.html) , which is supported by Authlete 2.3
  *   and newer versions.
  * @param audiences
  *   The audiences on the token exchange request
  * @param requestedTokenType
  * @param subjectToken
  * @param subjectTokenType
  * @param subjectTokenInfo
  * @param actorToken
  * @param actorTokenType
  * @param actorTokenInfo
  * @param assertion
  *   For RFC 7523 JSON Web Token (JWT) Profile for OAuth 2.0 Client Authentication and
  *   Authorization Grants
  * @param previousRefreshTokenUsed
  *   Indicate whether the previous refresh token that had been kept in the database for a short
  *   time was used
  * @param clientEntityId
  *   The entity ID of the client.
  * @param clientEntityIdUsed
  *   Flag which indicates whether the entity ID of the client was used when the request for the
  *   access token was made.
  */
case class TokenResponse(
    resultCode: Option[String] = None,
    resultMessage: Option[String] = None,
    action: Option[TokenResponseAction] = None,
    responseContent: Option[String] = None,
    username: Option[String] = None,
    password: Option[String] = None,
    ticket: Option[String] = None,
    accessToken: Option[String] = None,
    accessTokenExpiresAt: Option[Long] = None,
    accessTokenDuration: Option[Long] = None,
    refreshToken: Option[String] = None,
    refreshTokenExpiresAt: Option[Long] = None,
    refreshTokenDuration: Option[Long] = None,
    idToken: Option[String] = None,
    grantType: Option[String] = None,
    clientId: Option[Long] = None,
    clientIdAlias: Option[String] = None,
    clientIdAliasUsed: Option[Boolean] = None,
    subject: Option[String] = None,
    scopes: Option[Seq[String]] = None,
    properties: Option[Seq[Property]] = None,
    jwtAccessToken: Option[String] = None,
    resources: Option[Seq[String]] = None,
    accessTokenResources: Option[Seq[String]] = None,
    authorizationDetails: Option[AuthzDetails] = None,
    serviceAttributes: Option[Seq[Pair]] = None,
    clientAttributes: Option[Seq[Pair]] = None,
    grantId: Option[String] = None,
    audiences: Option[Seq[String]] = None,
    requestedTokenType: Option[TokenType] = None,
    subjectToken: Option[String] = None,
    subjectTokenType: Option[TokenType] = None,
    subjectTokenInfo: Option[TokenInfo] = None,
    actorToken: Option[String] = None,
    actorTokenType: Option[TokenType] = None,
    actorTokenInfo: Option[TokenInfo] = None,
    assertion: Option[String] = None,
    previousRefreshTokenUsed: Option[Boolean] = None,
    clientEntityId: Option[String] = None,
    clientEntityIdUsed: Option[Boolean] = None
)

object TokenResponse {

  given jsonCodec: JsonValueCodec[TokenResponse] = JsonCodecMaker.make(codecMakerConfig)

  given encoderTokenResponse: Encoder[TokenResponse] = Encoder.instance { t =>
    Json.fromFields {
      Seq(
        t.resultCode.map(v => "resultCode" -> v.asJson),
        t.resultMessage.map(v => "resultMessage" -> v.asJson),
        t.action.map(v => "action" -> v.asJson),
        t.responseContent.map(v => "responseContent" -> v.asJson),
        t.username.map(v => "username" -> v.asJson),
        t.password.map(v => "password" -> v.asJson),
        t.ticket.map(v => "ticket" -> v.asJson),
        t.accessToken.map(v => "accessToken" -> v.asJson),
        t.accessTokenExpiresAt.map(v => "accessTokenExpiresAt" -> v.asJson),
        t.accessTokenDuration.map(v => "accessTokenDuration" -> v.asJson),
        t.refreshToken.map(v => "refreshToken" -> v.asJson),
        t.refreshTokenExpiresAt.map(v => "refreshTokenExpiresAt" -> v.asJson),
        t.refreshTokenDuration.map(v => "refreshTokenDuration" -> v.asJson),
        t.idToken.map(v => "idToken" -> v.asJson),
        t.grantType.map(v => "grantType" -> v.asJson),
        t.clientId.map(v => "clientId" -> v.asJson),
        t.clientIdAlias.map(v => "clientIdAlias" -> v.asJson),
        t.clientIdAliasUsed.map(v => "clientIdAliasUsed" -> v.asJson),
        t.subject.map(v => "subject" -> v.asJson),
        t.scopes.map(v => "scopes" -> v.asJson),
        t.properties.map(v => "properties" -> v.asJson),
        t.jwtAccessToken.map(v => "jwtAccessToken" -> v.asJson),
        t.resources.map(v => "resources" -> v.asJson),
        t.accessTokenResources.map(v => "accessTokenResources" -> v.asJson),
        t.authorizationDetails.map(v => "authorizationDetails" -> v.asJson),
        t.serviceAttributes.map(v => "serviceAttributes" -> v.asJson),
        t.clientAttributes.map(v => "clientAttributes" -> v.asJson),
        t.grantId.map(v => "grantId" -> v.asJson),
        t.audiences.map(v => "audiences" -> v.asJson),
        t.requestedTokenType.map(v => "requestedTokenType" -> v.asJson),
        t.subjectToken.map(v => "subjectToken" -> v.asJson),
        t.subjectTokenType.map(v => "subjectTokenType" -> v.asJson),
        t.subjectTokenInfo.map(v => "subjectTokenInfo" -> v.asJson),
        t.actorToken.map(v => "actorToken" -> v.asJson),
        t.actorTokenType.map(v => "actorTokenType" -> v.asJson),
        t.actorTokenInfo.map(v => "actorTokenInfo" -> v.asJson),
        t.assertion.map(v => "assertion" -> v.asJson),
        t.previousRefreshTokenUsed.map(v => "previousRefreshTokenUsed" -> v.asJson),
        t.clientEntityId.map(v => "clientEntityId" -> v.asJson),
        t.clientEntityIdUsed.map(v => "clientEntityIdUsed" -> v.asJson)
      ).flatten
    }
  }

  given decoderTokenResponse: Decoder[TokenResponse] = Decoder.instance { c =>
    for {
      resultCode            <- c.downField("resultCode").as[Option[String]]
      resultMessage         <- c.downField("resultMessage").as[Option[String]]
      action                <- mapEmptyStringToNull(c.downField("action")).as[Option[TokenResponseAction]]
      responseContent       <- c.downField("responseContent").as[Option[String]]
      username              <- c.downField("username").as[Option[String]]
      password              <- c.downField("password").as[Option[String]]
      ticket                <- c.downField("ticket").as[Option[String]]
      accessToken           <- c.downField("accessToken").as[Option[String]]
      accessTokenExpiresAt  <- c.downField("accessTokenExpiresAt").as[Option[Long]]
      accessTokenDuration   <- c.downField("accessTokenDuration").as[Option[Long]]
      refreshToken          <- c.downField("refreshToken").as[Option[String]]
      refreshTokenExpiresAt <- c.downField("refreshTokenExpiresAt").as[Option[Long]]
      refreshTokenDuration  <- c.downField("refreshTokenDuration").as[Option[Long]]
      idToken               <- c.downField("idToken").as[Option[String]]
      grantType             <- c.downField("grantType").as[Option[String]]
      clientId              <- c.downField("clientId").as[Option[Long]]
      clientIdAlias         <- c.downField("clientIdAlias").as[Option[String]]
      clientIdAliasUsed     <- c.downField("clientIdAliasUsed").as[Option[Boolean]]
      subject               <- c.downField("subject").as[Option[String]]
      scopes                <- c.downField("scopes").as[Option[Seq[String]]]
      properties            <- c.downField("properties").as[Option[Seq[Property]]]
      jwtAccessToken        <- c.downField("jwtAccessToken").as[Option[String]]
      resources             <- c.downField("resources").as[Option[Seq[String]]]
      accessTokenResources  <- c.downField("accessTokenResources").as[Option[Seq[String]]]
      authorizationDetails  <- c.downField("authorizationDetails").as[Option[AuthzDetails]]
      serviceAttributes     <- c.downField("serviceAttributes").as[Option[Seq[Pair]]]
      clientAttributes      <- c.downField("clientAttributes").as[Option[Seq[Pair]]]
      grantId               <- c.downField("grantId").as[Option[String]]
      audiences             <- c.downField("audiences").as[Option[Seq[String]]]
      requestedTokenType <-
        mapEmptyStringToNull(c.downField("requestedTokenType")).as[Option[TokenType]]
      subjectToken <- c.downField("subjectToken").as[Option[String]]
      subjectTokenType <-
        mapEmptyStringToNull(c.downField("subjectTokenType")).as[Option[TokenType]]
      subjectTokenInfo         <- c.downField("subjectTokenInfo").as[Option[TokenInfo]]
      actorToken               <- c.downField("actorToken").as[Option[String]]
      actorTokenType           <- mapEmptyStringToNull(c.downField("actorTokenType")).as[Option[TokenType]]
      actorTokenInfo           <- c.downField("actorTokenInfo").as[Option[TokenInfo]]
      assertion                <- c.downField("assertion").as[Option[String]]
      previousRefreshTokenUsed <- c.downField("previousRefreshTokenUsed").as[Option[Boolean]]
      clientEntityId           <- c.downField("clientEntityId").as[Option[String]]
      clientEntityIdUsed       <- c.downField("clientEntityIdUsed").as[Option[Boolean]]
    } yield TokenResponse(
      resultCode = resultCode,
      resultMessage = resultMessage,
      action = action,
      responseContent = responseContent,
      username = username,
      password = password,
      ticket = ticket,
      accessToken = accessToken,
      accessTokenExpiresAt = accessTokenExpiresAt,
      accessTokenDuration = accessTokenDuration,
      refreshToken = refreshToken,
      refreshTokenExpiresAt = refreshTokenExpiresAt,
      refreshTokenDuration = refreshTokenDuration,
      idToken = idToken,
      grantType = grantType,
      clientId = clientId,
      clientIdAlias = clientIdAlias,
      clientIdAliasUsed = clientIdAliasUsed,
      subject = subject,
      scopes = scopes,
      properties = properties,
      jwtAccessToken = jwtAccessToken,
      resources = resources,
      accessTokenResources = accessTokenResources,
      authorizationDetails = authorizationDetails,
      serviceAttributes = serviceAttributes,
      clientAttributes = clientAttributes,
      grantId = grantId,
      audiences = audiences,
      requestedTokenType = requestedTokenType,
      subjectToken = subjectToken,
      subjectTokenType = subjectTokenType,
      subjectTokenInfo = subjectTokenInfo,
      actorToken = actorToken,
      actorTokenType = actorTokenType,
      actorTokenInfo = actorTokenInfo,
      assertion = assertion,
      previousRefreshTokenUsed = previousRefreshTokenUsed,
      clientEntityId = clientEntityId,
      clientEntityIdUsed = clientEntityIdUsed
    )
  }

}
