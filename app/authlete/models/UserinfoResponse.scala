/**
  * Authlete API Authlete API Document.
  *
  * The version of the OpenAPI document: 2.3.12 Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package authlete
package models

import scala.collection.immutable.Seq

import com.github.plokhotnyuk.jsoniter_scala.core.JsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.ConfiguredJsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMaker
import io.circe.{Decoder, Encoder, Json}
import io.circe.syntax.*

/**
  * @param resultCode
  *   The code which represents the result of the API call.
  * @param resultMessage
  *   A short message which explains the result of the API call.
  * @param action
  * @param claims
  *   The list of claims that the client application requests to be embedded in the ID token.
  * @param clientId
  *   The ID of the client application which is associated with the access token.
  * @param clientIdAlias
  *   The client ID alias when the authorization request for the access token was made.
  * @param clientIdAliasUsed
  *   The flag which indicates whether the client ID alias was used when the authorization request
  *   for the access token was made.
  * @param responseContent
  *   The content that the authorization server implementation can use as the value of
  *   `WWW-Authenticate` header on errors.
  * @param scopes
  *   The scopes covered by the access token.
  * @param subject
  *   The subject (= resource owner's ID).
  * @param token
  *   The access token that came along with the userinfo request.
  * @param properties
  *   The extra properties associated with the access token.
  * @param userInfoClaims
  *   The value of the `userinfo` property in the `claims` request parameter or in the `claims`
  *   property in an authorization request object. A client application may request certain claims
  *   be embedded in an ID token or in a response from the userInfo endpoint. There are several
  *   ways. Including the `claims` request parameter and including the `claims` property in a
  *   request object are such examples. In both cases, the value of the `claims` parameter/property
  *   is JSON. Its format is described in [5.5. Requesting Claims using the \"claims\" Request
  *   Parameter](https://openid.net/specs/openid-connect-core-1_0.html#ClaimsParameter). The
  *   following is an excerpt from the specification. You can find `userinfo` and `id_token` are
  *   top-level properties. ```json {   \"userinfo\":   {     \"given_name\": { \"essential\": true },     \"nickname\": null,     \"email\": { \"essential\": true },     \"email_verified\": { \"essential\": true },     \"picture\": null,     \"http://example.info/claims/groups\": null   },   \"id_token\":   {     \"auth_time\": { \"essential\": true },     \"acr\": { \"values\": [ \"urn:mace:incommon:iap:silver\" ] }   } } ````
  *   The value of this property is the value of the `userinfo` property in JSON format. For
  *   example, if the JSON above is included in an authorization request, this property holds JSON
  *   equivalent to the following. ```json {   \"given_name\": { \"essential\": true },   \"nickname\": null,   \"email\": { \"essential\": true },   \"email_verified\": { \"essential\": true },   \"picture\": null,   \"http://example.info/claims/groups\": null } ```
  *   Note that if a request object is given and it contains the `claims` property and if the
  *   `claims` request parameter is also given, the value of this property holds the former value.
  * @param serviceAttributes
  *   The attributes of this service that the client application belongs to.
  * @param clientAttributes
  *   The attributes of the client.
  * @param consentedClaims
  *   the claims that the user has consented for the client application to know.
  * @param requestedClaimsForTx
  *   Get names of claims that are requested indirectly by <i>\"transformed claims\"</i>. <p> A
  *   client application can request <i>\"transformed claims\"</i> by adding names of transformed
  *   claims in the `claims` request parameter. The following is an example of the `claims` request
  *   parameter that requests a predefined transformed claim named `18_or_over` and a transformed
  *   claim named `nationality_usa` to be embedded in the response from the userinfo endpoint. </p> ```json {   \"transformed_claims\": {     \"nationality_usa\": {       \"claim\": \"nationalities\",       \"fn\": [         [ \"eq\", \"USA\" ],         \"any\"       ]     }   },   \"userinfo\": {     \"::18_or_over\": null,     \":nationality_usa\": null   } } ```
  *   The example above assumes that a transformed claim named `18_or_over` is predefined by the
  *   authorization server like below. ```json {   \"18_or_over\": {     \"claim\": \"birthdate\",     \"fn\": [       \"years_ago\",       [ \"gte\", 18 ]     ]   } } ```
  *   In the example, the `nationalities` claim is requested indirectly by the `nationality_usa`
  *   transformed claim. Likewise, the `birthdate` claim is requested indirectly by the `18_or_over`
  *   transformed claim. When the `claims` request parameter of an authorization request is like the
  *   example above, this `requestedClaimsForTx` property will hold the following value. ```json [ \"birthdate\", \"nationalities\" ] ```
  *   It is expected that the authorization server implementation prepares values of the listed
  *   claims and passes them as the value of the `claimsForTx` request parameter when it calls the
  *   `/api/auth/userinfo/issue` API. The following is an example of the value of the `claimsForTx`
  *   request parameter. ```json {   \"birthdate\": \"1970-01-23\",   \"nationalities\": [ \"DEU\", \"USA\" ] } ```
  * @param requestedVerifiedClaimsForTx
  *   Names of verified claims that will be referenced when transformed claims are computed.
  * @param transformedClaims
  *   the value of the `transformed_claims` property in the `claims` request parameter of an
  *   authorization request or in the `claims` property in a request object.
  * @param clientEntityId
  *   The entity ID of the client.
  * @param clientEntityIdUsed
  *   Flag which indicates whether the entity ID of the client was used when the request for the
  *   access token was made.
  */
case class UserinfoResponse(
    resultCode: Option[String] = None,
    resultMessage: Option[String] = None,
    action: Option[IntrospectionResponseAction] = None,
    claims: Option[Seq[String]] = None,
    clientId: Option[Long] = None,
    clientIdAlias: Option[String] = None,
    clientIdAliasUsed: Option[Boolean] = None,
    responseContent: Option[String] = None,
    scopes: Option[Seq[String]] = None,
    subject: Option[String] = None,
    token: Option[String] = None,
    properties: Option[Seq[Property]] = None,
    userInfoClaims: Option[String] = None,
    serviceAttributes: Option[Seq[Pair]] = None,
    clientAttributes: Option[Seq[Pair]] = None,
    consentedClaims: Option[Seq[String]] = None,
    requestedClaimsForTx: Option[Seq[String]] = None,
    requestedVerifiedClaimsForTx: Option[Seq[Seq[String]]] = None,
    transformedClaims: Option[String] = None,
    clientEntityId: Option[String] = None,
    clientEntityIdUsed: Option[Boolean] = None
)

object UserinfoResponse {

  given jsonCodec: JsonValueCodec[UserinfoResponse] = JsonCodecMaker.make(codecMakerConfig)

  given encoderUserinfoResponse: Encoder[UserinfoResponse] = Encoder.instance { t =>
    Json.fromFields {
      Seq(
        t.resultCode.map(v => "resultCode" -> v.asJson),
        t.resultMessage.map(v => "resultMessage" -> v.asJson),
        t.action.map(v => "action" -> v.asJson),
        t.claims.map(v => "claims" -> v.asJson),
        t.clientId.map(v => "clientId" -> v.asJson),
        t.clientIdAlias.map(v => "clientIdAlias" -> v.asJson),
        t.clientIdAliasUsed.map(v => "clientIdAliasUsed" -> v.asJson),
        t.responseContent.map(v => "responseContent" -> v.asJson),
        t.scopes.map(v => "scopes" -> v.asJson),
        t.subject.map(v => "subject" -> v.asJson),
        t.token.map(v => "token" -> v.asJson),
        t.properties.map(v => "properties" -> v.asJson),
        t.userInfoClaims.map(v => "userInfoClaims" -> v.asJson),
        t.serviceAttributes.map(v => "serviceAttributes" -> v.asJson),
        t.clientAttributes.map(v => "clientAttributes" -> v.asJson),
        t.consentedClaims.map(v => "consentedClaims" -> v.asJson),
        t.requestedClaimsForTx.map(v => "requestedClaimsForTx" -> v.asJson),
        t.requestedVerifiedClaimsForTx.map(v => "requestedVerifiedClaimsForTx" -> v.asJson),
        t.transformedClaims.map(v => "transformedClaims" -> v.asJson),
        t.clientEntityId.map(v => "clientEntityId" -> v.asJson),
        t.clientEntityIdUsed.map(v => "clientEntityIdUsed" -> v.asJson)
      ).flatten
    }
  }

  given decoderUserinfoResponse: Decoder[UserinfoResponse] = Decoder.instance { c =>
    for {
      resultCode           <- c.downField("resultCode").as[Option[String]]
      resultMessage        <- c.downField("resultMessage").as[Option[String]]
      action               <- mapEmptyStringToNull(c.downField("action")).as[Option[IntrospectionResponseAction]]
      claims               <- c.downField("claims").as[Option[Seq[String]]]
      clientId             <- c.downField("clientId").as[Option[Long]]
      clientIdAlias        <- c.downField("clientIdAlias").as[Option[String]]
      clientIdAliasUsed    <- c.downField("clientIdAliasUsed").as[Option[Boolean]]
      responseContent      <- c.downField("responseContent").as[Option[String]]
      scopes               <- c.downField("scopes").as[Option[Seq[String]]]
      subject              <- c.downField("subject").as[Option[String]]
      token                <- c.downField("token").as[Option[String]]
      properties           <- c.downField("properties").as[Option[Seq[Property]]]
      userInfoClaims       <- c.downField("userInfoClaims").as[Option[String]]
      serviceAttributes    <- c.downField("serviceAttributes").as[Option[Seq[Pair]]]
      clientAttributes     <- c.downField("clientAttributes").as[Option[Seq[Pair]]]
      consentedClaims      <- c.downField("consentedClaims").as[Option[Seq[String]]]
      requestedClaimsForTx <- c.downField("requestedClaimsForTx").as[Option[Seq[String]]]
      requestedVerifiedClaimsForTx <-
        c.downField("requestedVerifiedClaimsForTx").as[Option[Seq[Seq[String]]]]
      transformedClaims  <- c.downField("transformedClaims").as[Option[String]]
      clientEntityId     <- c.downField("clientEntityId").as[Option[String]]
      clientEntityIdUsed <- c.downField("clientEntityIdUsed").as[Option[Boolean]]
    } yield UserinfoResponse(
      resultCode = resultCode,
      resultMessage = resultMessage,
      action = action,
      claims = claims,
      clientId = clientId,
      clientIdAlias = clientIdAlias,
      clientIdAliasUsed = clientIdAliasUsed,
      responseContent = responseContent,
      scopes = scopes,
      subject = subject,
      token = token,
      properties = properties,
      userInfoClaims = userInfoClaims,
      serviceAttributes = serviceAttributes,
      clientAttributes = clientAttributes,
      consentedClaims = consentedClaims,
      requestedClaimsForTx = requestedClaimsForTx,
      requestedVerifiedClaimsForTx = requestedVerifiedClaimsForTx,
      transformedClaims = transformedClaims,
      clientEntityId = clientEntityId,
      clientEntityIdUsed = clientEntityIdUsed
    )
  }

}
