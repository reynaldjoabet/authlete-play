/**
  * Authlete API Authlete API Document.
  *
  * The version of the OpenAPI document: 2.3.12 Contact: team@openapitools.org
  *
  * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
  * https://openapi-generator.tech Do not edit the class manually.
  */
package authlete
package models

import com.github.plokhotnyuk.jsoniter_scala.core.JsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.ConfiguredJsonValueCodec
import com.github.plokhotnyuk.jsoniter_scala.macros.JsonCodecMaker
import io.circe.{Decoder, Encoder, Json}
import io.circe.syntax.*

/**
  * @param kty
  *   The key type (EC or RSA)
  * @param use
  *   The key on the HSM. When the key use is \"sig\" (signature), the private key on the HSM is
  *   used to sign data and the corresponding public key is used to verify the signature. When the
  *   key use is \"enc\" (encryption), the private key on the HSM is used to decrypt encrypted data
  *   which have been encrypted with the corresponding public key
  * @param kid
  *   Key ID for the key on the HSM.
  * @param hsmName
  *   The name of the HSM. The identifier for the HSM that sits behind the Authlete server. For
  *   example, \"google\".
  * @param handle
  *   The handle for the key on the HSM. A handle is a base64url-encoded 256-bit random value (43
  *   letters) which is assigned by Authlete on the call of the /api/hsk/create API
  * @param publicKey
  *   The public key that corresponds to the key on the HSM.
  */
case class HskCreateRequest(
    kty: Option[String] = None,
    use: Option[String] = None,
    kid: Option[String] = None,
    hsmName: Option[String] = None,
    handle: Option[String] = None,
    publicKey: Option[String] = None
)

object HskCreateRequest {

  given jsonCodec: JsonValueCodec[HskCreateRequest] = JsonCodecMaker.make(codecMakerConfig)

  given encoderHskCreateRequest: Encoder[HskCreateRequest] = Encoder.instance { t =>
    Json.fromFields {
      Seq(
        t.kty.map(v => "kty" -> v.asJson),
        t.use.map(v => "use" -> v.asJson),
        t.kid.map(v => "kid" -> v.asJson),
        t.hsmName.map(v => "hsmName" -> v.asJson),
        t.handle.map(v => "handle" -> v.asJson),
        t.publicKey.map(v => "publicKey" -> v.asJson)
      ).flatten
    }
  }

  given decoderHskCreateRequest: Decoder[HskCreateRequest] = Decoder.instance { c =>
    for {
      kty       <- c.downField("kty").as[Option[String]]
      use       <- c.downField("use").as[Option[String]]
      kid       <- c.downField("kid").as[Option[String]]
      hsmName   <- c.downField("hsmName").as[Option[String]]
      handle    <- c.downField("handle").as[Option[String]]
      publicKey <- c.downField("publicKey").as[Option[String]]
    } yield HskCreateRequest(
      kty = kty,
      use = use,
      kid = kid,
      hsmName = hsmName,
      handle = handle,
      publicKey = publicKey
    )
  }

}
